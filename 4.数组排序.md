- [十大经典排序](https://www.cnblogs.com/onepixel/p/7674659.html)
- 先使用快排对数据集进行排序，此时的数据集已经达到了基本有序的状态，然后当分区的规模达到一定小时便停止快速排序算法，而是改用插入排序，因为插入排序在对基本有序的数据集排序有着接近线性的复杂度；

![img](https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png)





## [排序数组](https://leetcode-cn.com/problems/sort-an-array/)



### 快速排序

```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:  # 入口
        
        self.quicksort(nums, 0, len(nums) - 1)
        
        return nums
    

    def quicksort(self, nums, left, right):

        if left >= right:  return 

        pos = self.partation(nums, left, right)
        self.quicksort(nums, left, pos - 1)
        self.quicksort(nums, pos + 1, right)
    
    def partation(self, nums, left, right):
        
        pivot = randint(left, right)  # 随机选择基准， 然后和right位置元素交换，使得right位置为基准，要不然有时候会超时
        nums[pivot], nums[right] = nums[right], nums[pivot]
        pre_min_povit = left - 1  # pre_min_povit记录上一个小于基准的位置

        for cur_pos in range(left,  right):  # cur_pos作为当前指针使用，如果找到小于基准，则把pre_min_povit += 1，然后互换位置，因为pre_min_povit记录上一个小于基准的位置，所以在pre_min_povit之后，cur_pos之前元素都大于基准
            if nums[cur_pos] < nums[right]:
                pre_min_povit += 1
                nums[cur_pos], nums[pre_min_povit] = nums[pre_min_povit], nums[cur_pos]
        
        pre_min_povit += 1
        nums[pre_min_povit], nums[right] = nums[right], nums[pre_min_povit]  # 将povit放到正确位置上

        return pre_min_povit
```



### 归并排序

```Python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:

        return self.mergesort(nums)
    

    def mergesort(self, nums):

        n = len(nums)
        if n <= 1:  return nums  # 归并排序必须返回值给lft_part和right_part
        
        mid = n // 2

        left_part = self.mergesort(nums[:mid])
        right_part = self.mergesort(nums[mid:])

        return self.merge(left_part, right_part)
    

    def merge(self, left_part, right_part):
        
        merged = []
        idx_left, idx_right = 0, 0

        while idx_left < len(left_part) and idx_right < len(right_part):
            if left_part[idx_left] < right_part[idx_right]:
                merged.append(left_part[idx_left])
                idx_left += 1
            else:
                merged.append(right_part[idx_right])
                idx_right += 1
        
        # 必定有一个后面是空的
        merged += left_part[idx_left:]  
        merged += right_part[idx_right:] 

        return merged
```



### 堆排序

```Python
class Solution:
    def max_heapify(self, heap, root, heap_len):
        
        p = root  # 当前节点
        while p * 2 + 1 < heap_len:  # 确保左边子节点存在
            l, r = p * 2 + 1, p * 2 + 2
            # nex代表左右最大值的节点
            if heap_len > r and heap[r] > heap[l]: 
                nex = r
            else:
                nex = l
            if heap[p] < heap[nex]:
                heap[p], heap[nex] = heap[nex], heap[p]
                p = nex
            else:
                break
        
    def build_heap(self, heap):
        for i in range(len(heap) - 1, -1, -1):
            self.max_heapify(heap, i, len(heap))  # 建堆时i节点为根结点 

    def sortArray(self, nums):
        
        self.build_heap(nums)
        for i in range(len(nums) - 1, -1, -1):
            nums[i], nums[0] = nums[0], nums[i]
            self.max_heapify(nums, 0, i)  # 大根堆0位置为最大元素，交换后时i位置之后都排好序了，所以以0位置为根，堆长度为i 
            
        return nums
```



### 题目



#### [数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

- 快排后，直接返回nums[-k], 复杂度 O(N log N) 


```Python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:

        nums = sorted(nums)
        return nums[-k]
```



#### ？[最大间距](https://leetcode-cn.com/problems/maximum-gap/)

- 桶排序：https://leetcode-cn.com/problems/maximum-gap/solution/python3-tong-pai-xu-by-yanghk/

```python
class Solution:
    def maximumGap(self, nums: List[int]) -> int:

        if len(nums) < 2: return 0

        minvalue, maxvalue = min(nums), max(nums)
        each_bucket_len = max(1, (maxvalue - minvalue) // (len(nums) - 1)) # 桶的数量应该比nums数量少1[3个节点有2段]
        buckets = [[] for _ in range((maxvalue - minvalue) // each_bucket_len + 1)] # 多放一个桶，保证有一个桶是空的，那么最大距离就在桶间而不是桶内

        for i, value in enumerate(nums):
            idx = (value - minvalue) // each_bucket_len
            buckets[idx].append(value)

        maxgap, premax = 0, max(buckets[0])

        for i in range(1, len(buckets)):
            if buckets[i]:
                curmin, curmax = min(buckets[i]), max(buckets[i])
                maxgap = max(maxgap, curmin - premax)
                premax = curmax
        
        return maxgap
```



#### ？[ 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

```python
class Solution:
    def reversePairs(self, nums: List[int]) -> int:

        def mergesort(l, r):
             # 终止条件
            if l >= r: return 0
            # 递归划分
            m = l + (r - l) // 2
            res = mergesort(l, m) + mergesort(m + 1, r)
            # 合并阶段
            i, j = l, m + 1
            tmp = []

            while i <= m and j <= r:
                if nums[i] <= nums[j]:
                    tmp.append(nums[i])
                    i += 1
                else:
                    tmp.append(nums[j])
                    j += 1
                    res += m - i + 1  # 统计逆序对
            
            tmp += nums[i: m + 1]
            tmp += nums[j: r + 1]

            nums[l: r + 1] = tmp
       
            return res
        
        return mergesort(0, len(nums) - 1)
```



#### ？[翻转对](https://leetcode-cn.com/problems/reverse-pairs/)

```python
class Solution:
    def find_reversed_pairs(self, nums, l, r, mid):
        
        res = 0
        j = mid + 1

        for i in range(l, mid + 1):
            while j <= r and nums[i] > 2 * nums[j]:
                res += mid - i + 1
                j += 1

        return res

    def mergesort(self, nums, tmp, l, r):

        if l >= r: return 0

        mid = l + (r - l) // 2
        res = self.mergesort(nums, tmp, l, mid) + self.mergesort(nums, tmp, mid + 1, r) + self.find_reversed_pairs(nums, l, r, mid)

        i, j, k = l, mid + 1, l

        while i <= mid and j <= r:
            if nums[i] <= nums[j]:
                tmp[k] = nums[i]
                i += 1
            else:
                tmp[k] = nums[j]
                j += 1
            k += 1

        while i <= mid:
            tmp[k] = nums[i]
            i += 1
            k += 1
        while j <= r:
            tmp[j] = nums[j]
            j += 1
            k += 1
        
        nums[l: r + 1] = tmp[l: r + 1]

        return res

    def reversePairs(self, nums: List[int]) -> int:
        if not nums: return 0
        tmp = [0 for _ in range(len(nums))]
        return self.mergesort(nums, tmp, 0, len(nums) - 1)
```



