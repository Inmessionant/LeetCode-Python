# 二叉树



### 二叉树的遍历



**前序遍历**：**先访问根节点**，再前序遍历左子树，再前序遍历右子树
**中序遍历**：先中序遍历左子树，**再访问根节点**，再中序遍历右子树
**后序遍历**：先后序遍历左子树，再后序遍历右子树，**再访问根节点**

- 以根访问顺序决定是什么遍历
- 左子树都是优先右子树



#### 递归遍历

- 递归实现二叉树遍历非常简单，不同顺序区别仅在于访问父结点顺序 

```python
# 前序遍历
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        def preorder(root: TreeNode):
            if not root:
                return
            res.append(root.val)
            preorder(root.left)
            preorder(root.right)
        
        res = []
        preorder(root)
        return res

# 中序遍历
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        def inorder(root: TreeNode):
          if not root:
            return 
          inorder(root.left)
          res.append(root.val)
          inorder(root.right)
        
        res = []
        inorder(root)
        return res

# 后序遍历
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        def postorder(root:TreeNode):
            if not root:
                return
            postorder(root.left)
            postorder(root.right)
            res.append(root.val)
        
        res = []
        postorder(root)
        return res 
```



#### [迭代前序](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

对 **中** 进行栈操作，作为标记 	**中 - 左 - 右 **

```python
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        
        res = []
        if not root:
            return res
        
        node = root
        stack = []

        while node or stack:
            while node:
                res.append(node.val)
                stack.append(node)
                node = node.left # 到叶子结点时候为None，跳出循环
            
            node = stack.pop() # 上一个node
            node = node.right
        
        return res
```



#### [迭代中序](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

对 **中** 进行栈操作，作为标记（先用指针找到每颗子树的最左下角，然后进行进出栈操作）. **左 -  中 - 右**

```Python
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]: 
        
        res = []

        if not root:
            return res

        node = root
        stack = []

        while node or stack:
            while node:
                stack.append(node)
                node = node.left # # 到叶子结点时候为None，跳出循环
            
            node = stack.pop()
            res.append(node.val)
            node = node.right

        return res
```



#### [迭代后序](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

- 前序遍历是 **中 - 左 - 右**，后序遍历是**左 - 右 - 中** ，将前序遍历的左右调换位置可以得到中右左，反过来打印就是左右中；


```Python
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        
        res = []
        if not root:
            return res
        
        node = root
        stack = []

        while node or stack:
            while node:
                res.append(node.val)
                stack.append(node)
                node = node.right
            
            node = stack.pop()
            node = node.left
        
        return res[::-1]
        
```

- 在这种遍历中，每个根节点都要经过三次：第一次遇到它时要立即转去处理其左子树，第二次从左子树经由它转去处理右子树，第三次从右子树回来才应该处理根节点数据，然后返回上一层；

```python
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        
        res = []

        if not root:
            return res
        
        stack = []
        prev = None
        node = root

        while node or stack:
            while node:
                stack.append(node)
                node = node.left
            
            node = stack.pop()
            if not node.right or node.right == prev:
                res.append(node.val)
                prev = node
                node = None
            else:
                stack.append(node)
                node = node.right
        
        return res
```



#### [层次遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

BFS使用队列，把每个还没有搜索到的点依次放入队列，然后再弹出队列的头部元素当做当前遍历点。如果要**确定当前遍历到了哪一层**，增加了level表示当前遍历到二叉树中的哪一层了，size表示在当前遍历层有多少个元素，也就是队列中的元素数，我们把这些元素一次性遍历完，即把当前层的所有元素都向外走了一步。二叉树的层次遍历，所以同一层的节点应该放在一起。使用队列保存每层的所有节点，每次把队列里的原先所有节点进行出队列操作，再把每个元素的非空左右子节点进入队列。因此即可得到每层的遍历。

```python
#模版（确定在哪一层）
level = 0 #记录层数
while queue：
    size = len(queue) # 当前层结点数
    for _ in range(size):
        cur = queue.popleft()
        for 节点 in cur的所有相邻节点： # 二叉树直接检查左右子结点
            if 该节点有效且未被访问过：
                queue.append(该节点)    
```

```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
      
      	res = []  # 结果集
        if not root: return res # 特殊情况，root为空直接返回
        # 下面就是BFS模板内容，BFS关键在于队列的使用
        queue = deque()
        queue.append(root)  # 压入初始节点
        
        while queue:
            size = len(queue)
            level = []  # 临时变量，记录当前层的节点
            for _ in range(size):  # 遍历某一层的节点
                node = queue.popleft()  # 将要处理的节点弹出
                level.append(node.val)
                if node.left:  # 如果当前节点有左右节点，则压入队列，根据题意注意压入顺序，先左后右，
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(level)  # 某一层的节点都处理完之后，
            
        return res
```



#### 分治遍历 

```Python
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]: # 前序遍历
        
        if not root: # 终止条件，应为要赋值，所以return[]
            return []
        # 分段处理
        left_result = self.preorderTraversal(root.left)
        right_result = self.preorderTraversal(root.right)
        # 合并结果
        return [root.val] + left_result + right_result
```



#### Morris遍历

**中-左-右，对于有左子树的节点遍历两次，没有左子树的节点遍历一次，通过将打印放在不同位置可以变为前/中/后序遍历**

```
1.cur无左子树，cur=cur.right;
2.cur有左子树，找到左子树上最右节点mostright:
	1.mostright的右孩子为None（第一次遍历），mostright.right=cur,cur=cur.left;
	2.mostright的右孩子为cur（第二次遍历），mostright.right=None,cur=cur.right;
```



#### 