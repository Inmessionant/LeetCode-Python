# 数组



- **数组是存放在连续内存空间上的相同类型数据的集合，可以方便的通过下标索引的方式获取到下标下对应的数据；**

![算法通关数组](2.%E6%95%B0%E7%BB%84.assets/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%84.png)



- **数组下标都是从0开始的，数组内存空间的地址是连续的，但因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址；**

​       例如删除下标为3的元素，需要对下标为3的元素后面的所有元素都要做移动操作，如图所示：

![算法通关数组1](2.%E6%95%B0%E7%BB%84.assets/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%841.png)



## [二分查找](https://leetcode-cn.com/problems/binary-search/)



**二分查找，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)；**



### 模板1

- **定义 target 是在一个在左闭右闭的区间里，也就是[left, right] ；**
- 区间的定义这就决定了二分法的代码应该如何写，**因为定义target在[left, right]区间，所以有如下两点：**
  - while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=；
  - if (nums[mid] > target) right 要赋值为 mid - 1，因为当前这个nums[mid]一定不是target，那么接下来要查找的左区间结束下标位置就是 mid - 1；
- **适用范围：**
  - 不需要找第一个、最后一个位置，或者没有重复元素；
  - 如果搜索失败，left 是第一个大于 target 的索引，right 是最后一个小于 target 的索引;

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        
        l, r = 0, len(nums) - 1
        
        while l <= r:
            mid = l + (r - l) // 2  # 这样写的目的一个是为了防止 (left + right)出现溢出，一个是用右移操作替代除法提升性能;
            if nums[mid] == target:
                return mid
            elif nums[mid] > target:  # target 在左区间，所以[left, mid - 1]
                r = mid - 1
            else:  # target 在右区间，所以[mid + 1, right]
                l = mid + 1
        
        return -1
```



### 模板2

- **定义 target 是在一个在左闭右开的区间里，也就是[left, right)** ；
- 区间的定义这就决定了二分法的代码应该如何写，**因为定义target在[left, right)区间，**while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的；
- 退出循环的时候有 `left == right` 成立，因此无需考虑返回 `left`还是 `right`，区间`[left, right]`只剩下成 1 个元素，这个元素被漏掉了，它有可能就是我们要找的元素；
- **适用范围：**
  - 第一种情况：
    - 数组有序，但包含重复元素；
    - 数组部分有序，且不包含重复元素；
  - 第二种情况：
    - 数组部分有序，且包含重复元素；

- https://leetcode.cn/problems/binary-search/solution/leetcode-offer-er-fen-cha-zhao-san-da-mo-0mn7/



#### 找左边界

- 求非降序范围[l, r)内第一个不小于target的值的位置；
- 划分` [left, mid]` 与` [mid + 1, right] `，**mid 被分到左边，**对应 `mid = left + (right - left) // 2;`

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        # `[first, last)`左闭右开，所以l, r = 0, len(nums) - 1
        l, r = 0, len(nums) - 1
        
        while l < r:
            mid = l + (r - l) // 2
            if nums[mid] < target:  # 因为是[x, x)，所以l要取值mid+1
                l = mid + 1
            else:  # mid 被分到左边
                r = mid

        if nums[l] == target:
            return l
        
        return -1
```



#### 找右边界

- 划分` [left, mid - 1] `与 `[mid, right] `，**mid 被分到右边**，对应  `mid = left + (right - left + 1) // 2;`

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        
        l, r = 0, len(nums) - 1

        while l < r:
            mid = l + (r - l + 1) // 2
            if target < nums[mid]:  # 因为是[x, x)，所以r要取值mid - 1
                r = mid - 1
            else:  # mid 被分到右边
                l = mid
        
        if nums[r] == target:
            return r
        else:
            return -1     
```



### 题目



#### [搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

- 使用模板 1

```Python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        
        l, r = 0, len(nums) - 1
        
        while l <= r:
            mid = l + (r - l) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] > target:
                r = mid - 1
            else:
                l = mid + 1
        
        return l  # 若不存在，l为第一个大于目标值的索引（插入位置），r为最后一个小于目标值的索引
```

- 模板2
- **为何令right=length-1而非length:**考虑极端情况 nums 序列是单调递增的，我们不断更新 left = mid + 1 直到 left = len(nums) - 1 ,若 right=len(nums) , 此时仍未满足终止条件，所以还会继续判断 mid 和 mid+1 对应元素的大小关系，但是 mid+1 已经超出边界，**所以查找时候初始化为length-1**；

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:

        n = len(nums)   # 模板2的r初始化为len(nums) - 1，是确定target在nums里面，如果target直接大于nums最大值，返回最后位置即可；
        if target > nums[n-1]: 
            return n

        l, r = 0, n - 1

        while l < r:
            mid = l + (r - l) // 2
            if target > nums[mid]:
                l = mid + 1
            else:
                r = mid

        return l
```



#### [在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

使用模板 2 

```Python
class Solution:
    def searchRange(self, nums, target):
        
        Range = [-1, -1]
        
        if not nums:
            return Range
        
        # 找左边第一次出现
        l, r = 0, len(nums) - 1
        while l < r:
            mid = l + (r - l) // 2
            if nums[mid] < target:
                l = mid + 1
            else:
                r = mid

        if nums[l] == target:
            Range[0] = l 
        else: # 左边都找不到，nums中没有target
            return Range 
        
        # 找右边第一次出现
        l, r = 0, len(nums) - 1
        while l < r:
            mid = l + (r - l + 1) // 2 
            if nums[mid] > target:
                r = mid - 1
            else:
                l = mid
            
        Range[1] = r # 由于能走到这里，说明在数组中一定找得到目标元素，因此这里不用再做一次判断
        
        return Range
```



#### [ x 的平方根 ](https://leetcode.cn/problems/sqrtx/)

```python
class Solution:
    def mySqrt(self, x: int) -> int:

        l, r, res = 0, x, -1

        while l <= r:
            mid = l + (r - l) // 2
            cur_pow = mid ** 2
            if cur_pow == x:
                return mid
            elif cur_pow > x:
                r = mid - 1
            else:
                l = mid + 1
        
        return r  # 查找失败时，r为最后一个小于math.sqrt(x)的整数
```



#### [有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/)

```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:

        l, r = 0, num

        while l <= r:  # 用模板一，因为查找失败时l位置为小于target的最大整数
            mid = l + (r - l) // 2
            cur_pow = mid ** 2  # 只用计算一次

            if cur_pow == num:
                return True  # 完全平方数返回True
            elif cur_pow > num:
                r = mid - 1
            else:
                l = mid + 1
        
        return False  # 查找失败，返回False
```



#### [寻找峰值](https://leetcode.cn/problems/find-peak-element/)

```python
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        l, r = 0, len(nums) - 1

        while l < r:
            mid = l + (r - l) //2
            # 如果你往下坡方向走，也许可能遇到新的山峰，但是也许是一个一直下降的坡，最后到边界;但是如果你往上坡方向走，就算最后一直上的边界，由于最边界是负无穷，所以就一定能找到山峰.总的一句话，往递增的方向上，二分，一定能找到，往递减的方向只是可能找到，也许没有;
            if nums[mid] < nums[mid+1]:
                l = mid + 1
            else:
                r = mid
        
        return l
```



