- [十大经典排序](https://www.cnblogs.com/onepixel/p/7674659.html)

![img](https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png)





## [排序数组](https://leetcode-cn.com/problems/sort-an-array/)





[二叉堆](https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/er-cha-dui-xiang-jie-shi-xian-you-xian-ji-dui-lie)



### 快速排序

先使用快排对数据集进行排序，此时的数据集已经达到了基本有序的状态然后当分区的规模达到一定小时，便停止快速排序算法，而是改用插入排序，因为插入排序在对基本有序的数据集排序有着接近线性的复杂度；

```python
class Solution:
    def partition(self, nums, l ,r):
        #随机选择基准， 然后和r位置元素交换，使得r位置为基准，要不然有时候会超时
        pivot = randint(l, r)
        nums[pivot], nums[r] = nums[r], nums[pivot]
        i = l - 1 # i记录j之前上一个小于基准的位置
        for j in range(l, r): #j作为当前指针使用，如果找到小于基准，则把i+=1，然后互换，因为i是j之前第一个小于基准位置，i之后，j之前元素都大于基准
            if nums[j] < nums[r]:
                i += 1
                nums[j], nums[i] = nums[i], nums[j]
        i += 1
        nums[i], nums[r] = nums[r], nums[i]
        return i

    def quicksort(self, nums, l , r):
        
        if l >= r:
            return
        
        pos = self.partition(nums, l, r)
        self.quicksort(nums, l, pos - 1)
        self.quicksort(nums, pos + 1, r)

    def sortArray(self, nums: List[int]) -> List[int]:
        self.quicksort(nums, 0, len(nums) - 1)
        return nums
```



### 归并排序

```Python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        if len(nums) <= 1: # 归并排序必须返回值给lft和right，但是快速排序不用
            return nums
        mid = len(nums) // 2

        left = self.sortArray(nums[:mid])
        right = self.sortArray(nums[mid:])

        return self.merge(left, right)

    def merge(self, left, right):
        res = []
        i, j = 0, 0

        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                res.append(left[i])
                i += 1
            else:
                res.append(right[j])
                j += 1
        res += left[i:]
        res += right[j:]
        return res
```



### 堆排序

```Python
class Solution:
    def max_heapify(self, heap, root, heap_len):
        
        p = root
        while p * 2 + 1 < heap_len:
            l, r = p * 2 + 1, p * 2 + 2
            # 判断左右最大值
            if heap_len <= r or heap[r] < heap[l]: # or连接顺序不能变，首先判断r存在性，然后再比较l，r位置值大小，要不然会出现不检查r存在性直接使用heap[r]越界情况；
                nex = l
            else:
                nex = r
            if heap[p] < heap[nex]:
                heap[p], heap[nex] = heap[nex], heap[p]
                p = nex
            else:
                break
        
    def build_heap(self, heap):
        for i in range(len(heap) - 1, -1, -1):
            self.max_heapify(heap, i, len(heap))

    def heap_sort(self, nums):
        
        self.build_heap(nums)
        for i in range(len(nums) - 1, -1, -1):
            nums[i], nums[0] = nums[0], nums[i]
            self.max_heapify(nums, 0, i)
            
        return nums
```

[动画展示](https://www.bilibili.com/video/av18980178/)



## 题目



### [数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

- 快排后，直接返回nums[-k], 复杂度 O(N log N) 


```Python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:

        nums = sorted(nums)
        return nums[-k]
```



### [最大间距](https://leetcode-cn.com/problems/maximum-gap/)

```python
class Solution:
    def maximumGap(self, nums: List[int]) -> int:

        if len(nums) < 2: return 0

        minvalue, maxvalue = min(nums), max(nums)
        each_bucket_len = max(1, (maxvalue - minvalue) // (len(nums) - 1)) # 桶的数量应该比nums数量少1[3个节点有2段]
        buckets = [[] for _ in range((maxvalue - minvalue) // each_bucket_len + 1)] # 多放一个桶，保证有一个桶是空的，那么最大距离就在桶间而不是桶内

        for i, value in enumerate(nums):
            idx = (value - minvalue) // each_bucket_len
            buckets[idx].append(value)

        maxgap, premax = 0, max(buckets[0])

        for i in range(1, len(buckets)):
            if buckets[i]:
                curmin, curmax = min(buckets[i]), max(buckets[i])
                maxgap = max(maxgap, curmin - premax)
                premax = curmax
        
        return maxgap
```

https://leetcode-cn.com/problems/maximum-gap/solution/python3-tong-pai-xu-by-yanghk/



### [ 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

```python
class Solution:
    def reversePairs(self, nums: List[int]) -> int:

        def mergesort(l, r):
             # 终止条件
            if l >= r: return 0
            # 递归划分
            m = l + (r - l) // 2
            res = mergesort(l, m) + mergesort(m + 1, r)
            # 合并阶段
            i, j = l, m + 1
            tmp = []

            while i <= m and j <= r:
                if nums[i] <= nums[j]:
                    tmp.append(nums[i])
                    i += 1
                else:
                    tmp.append(nums[j])
                    j += 1
                    res += m - i + 1  # 统计逆序对
            
            tmp += nums[i: m + 1]
            tmp += nums[j: r + 1]

            nums[l: r + 1] = tmp
       
            return res
        
        return mergesort(0, len(nums) - 1)
```



### [翻转对](https://leetcode-cn.com/problems/reverse-pairs/)

```python
class Solution:
    def find_reversed_pairs(self, nums, l, r, mid):
        
        res = 0
        j = mid + 1

        for i in range(l, mid + 1):
            while j <= r and nums[i] > 2 * nums[j]:
                res += mid - i + 1
                j += 1

        return res

    def mergesort(self, nums, tmp, l, r):

        if l >= r: return 0

        mid = l + (r - l) // 2
        res = self.mergesort(nums, tmp, l, mid) + self.mergesort(nums, tmp, mid + 1, r) + self.find_reversed_pairs(nums, l, r, mid)

        i, j, k = l, mid + 1, l

        while i <= mid and j <= r:
            if nums[i] <= nums[j]:
                tmp[k] = nums[i]
                i += 1
            else:
                tmp[k] = nums[j]
                j += 1
            k += 1

        while i <= mid:
            tmp[k] = nums[i]
            i += 1
            k += 1
        while j <= r:
            tmp[j] = nums[j]
            j += 1
            k += 1
        
        nums[l: r + 1] = tmp[l: r + 1]

        return res

    def reversePairs(self, nums: List[int]) -> int:
        if not nums: return 0
        tmp = [0 for _ in range(len(nums))]
        return self.mergesort(nums, tmp, 0, len(nums) - 1)
```



