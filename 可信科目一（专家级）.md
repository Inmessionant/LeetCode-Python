```
1.双数月简单？



```



### 2023.10.13



#### 1.

```python
'''
题目：使用栈模拟计算器的基本操作，该计算器共有a~t 20个栈，其中共有PUSH、POP、ADD、MUL、DIV五个操作

PUSH(stack_name， num)：将num压入对应的栈中，若栈中大小超过32，则什么都不做

POP（stack_name, num）：将栈顶对应数字弹出栈

ADD（stack_name1，stack_name2）：将栈1和栈2栈顶数字相加，并将结果更新到栈1栈顶

MUL（stack_name1，stack_name2）：将栈1和栈2栈顶数字相乘，并将结果更新到栈1栈顶

DIV（stack_name1，stack_name2）：将栈1和栈2栈顶数字相除，并将商更新到栈1栈顶，将余数更新至栈2栈顶

注意：1.所有操作均合法（不存在POP空，除0的情况）

2.若计算结果大于1024，则对结果取余

3.若栈为空，输出-1


例1：输入：instructions = ["PSH a 8", "PSH d 3", "PSH c 3", "ADD a c", "DIV a c", "MUL d c", "POP c"]
输出：[3, -1, -1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]


输入例子如下：

命令“ADD a b”，表示获得栈a、b栈顶的元素并相加，并赋值给栈a顶部元素；
命令“ADD a b”，表示获得栈a、b栈顶的元素并相减，并赋值给栈a顶部元素；
命令“PSH a 3”，表示将3入栈a；
命令“POP a ”，表示如果栈a顶有元素就将其弹出；
命令“DIV a b”，表示获得栈a、b栈顶的元素并相除，除数赋给栈a顶，余数赋给栈b顶。
        栈顶无元素则返回-1，任意操作数值大于1024需要取模。

        解法：模拟即可
'''
class Solution:
    def stack_calculator(self, instructions: List[str]) -> List[int]:
        stack = [[] for _ in range(20)]
        cal_set = {"ADD", "MUL", "DIV"}
        instructions_list = [ins.split() for ins in instructions]
        for ins in instructions_list:
            if ins[0] in cal_set:
                stack1 = stack[ord(ins[1]) - ord("a")]
                stack2 = stack[ord(ins[2]) - ord("a")]
                self.calculate(ins[0], stack1, stack2)
            elif ins[0] == "PSH":
                stack1 = stack[ord(ins[1]) - ord("a")]
                if len(stack1) < 32:
                    stack1.append(int(ins[2]))
            else:
                stack1 = stack[ord(ins[1]) - ord("a")]
                if stack1:
                    stack1.pop()
        res = []
        for s in stack:
            if not s:
                res.append(-1)
            else:
                res.append(s[-1])
        return res

    def calculate(self, flag, stack1, stack2):
        num1 = stack1[-1]
        num2 = stack2[-1]
        if flag == "ADD":
            res = num1 + num2
            if res > 1024:
                res %= 1024
            stack1[-1] = res
            return
        if flag == "MUL":
            res = num1 * num2
            if res > 1024:
                res %= 1024
            stack1[-1] = res
            return
        if flag == "DIV":
            stack1[-1] = num1 // num2
            stack2[-1] = num1 % num2
            return
```

```python
from typing import List


class Solution:
    def __init__(self):
        self.stacks = {"a": [], "b": [], "c": [], "d": [], "e": [], "f": [], "g": [], "h": [], "i": [],
                       "j": [], "k": [], "l": [], "m": [], "n": [], "o": [], "p": [], "q": [], "r": [],
                       "s": [], "t": []}

    def stack_calculator(self, instructions: List[str]) -> List[int]:
        for command in instructions:
            command_list = list(command.split())
            if command_list[0] == "PSH":
                self.push(command_list[1], int(command_list[2]))
            if command_list[0] == "POP":
                self.pop(command_list[1])
            if command_list[0] == "ADD":
                self.add(command_list[1], command_list[2])
            if command_list[0] == "MUL":
                self.mul(command_list[1], command_list[2])
            if command_list[0] == "DIV":
                self.div(command_list[1], command_list[2])
        res = []
        for v in self.stacks.values():
            if not v:
                res.append(-1)
            else:
                res.append(v[-1])
        return res

    def push(self, stack_name, num):
        stack = self.stacks[stack_name]
        if len(stack) > 32:
            return
        stack.append(num)

    def pop(self, stack_name):
        stack = self.stacks[stack_name]
        stack.pop()

    def add(self, stack_name1, stack_name2):
        stack1 = self.stacks[stack_name1]
        stack2 = self.stacks[stack_name2]
        res = stack1[-1] + stack2[-1]
        stack1[-1] = res if res < 1024 else res % 1024

    def mul(self, stack_name1, stack_name2):
        stack1 = self.stacks[stack_name1]
        stack2 = self.stacks[stack_name2]
        res = stack1[-1] * stack2[-1]
        stack1[-1] = res if res < 1024 else res % 1024

    def div(self, stack_name1, stack_name2):
        stack1 = self.stacks[stack_name1]
        stack2 = self.stacks[stack_name2]
        div_res = stack1[-1] // stack2[-1]
        mod = stack1[-1] % stack2[-1]
        stack1[-1] = div_res if div_res < 1024 else div_res % 1024
        stack2[-1] = mod if mod < 1024 else mod % 1024
```



#### 2.

```python
'''
题目：磁盘区间分为读和写，每个磁盘空间由扇区组成，扇区大小为sectorSize，给定一个扇区大小和已读区间，我们要对已读磁盘区间进行合并，并根据sectorSize大小重新划分区间，输出最终划分后的区间



例1：输入：sector_size = 32

op_array =[[0, 30], [10, 33], [130, 150], [151, 158], [60, 100], [130, 150], [20, 50]]

输出：[[0, 31], [32, 50], [60, 63], [64, 95], [96, 100], [130, 158]]

解释：磁盘区间进行合并后为[[0, 50], [60, 100], [130, 158]]，size大小为32，所以将合并后的区间，按照32的大小进行划分，对于区间[0,50]：0-31为第一个，32-50为第二个



例2：输入：sector_size = 64

op_array =[[77, 128], [130, 130], [2147483502, 2147483632], [2147483600, 2147483647]]

输出：[[77, 127], [128, 128], [130, 130], [2147483502, 2147483519], [2147483520, 2147483583], [2147483584, 2147483647]]



解法：合并区间过程与力扣56【合并区间】是一样的，注意一个坑点：[start1, end1]和[end1 + 1, end2]要合并为[start1, end2]（第一个例子就是这种情况，我一开始就没考虑到，如果没有例1估计很多人部分通过想不到错在哪了）,划分区间可以通过对区间start和end进行整除size，得到该区间起始和结束属于第几块，然后对这个块之间进行划分



题目：题干也比较清晰，模拟硬盘空间清理。

        先进行区间合并，再按给定的sector_size（扇区大小，2的整数倍）进行分区。区间包含sector_size的整数倍时，需要分割。

        如sector_size=32时，合并后区间为[30，70]，分割后为[[30, 31], [32, 63], [64, 70]]。

解法：按题目意思先进行区间合并，再分割。注意合并前先按第一个元素从小到大排序。
'''
class Solution:
    def io_merge(self, sector_size: int, op_array: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
        if not op_array:
            return []
        op_array.sort(key=lambda x: x[0])
        array_list = [list(array) for array in op_array]
        temp = [array_list[0]]
        for i in range(1, len(array_list)):
            if array_list[i][0] > temp[-1][1] + 1:
                temp.append(array_list[i])
            else:
                if temp[-1][1] < array_list[i][1]:
                    temp[-1][1] = array_list[i][1]
        res = []
        for array in temp:
            times = array[1] // sector_size - array[0] // sector_size
            if times == 0:
                res.append(array)
            else:
                dev = array[0] // sector_size
                res.append([array[0], (dev + 1) * sector_size - 1])
                temp_num = 0
                for _ in range(times - 1):
                    temp_num += 1
                    res.append([(dev + temp_num) * sector_size, (dev + 1 + temp_num) * sector_size - 1])
                res.append([(dev + 1 + temp_num) * sector_size, array[1]])
        return res
```

```python
from typing import List, Tuple


class Solution:
    def io_merge(self, sector_size: int, op_array: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
        if not op_array:
            return []
        arr = self.merge_interval(op_array)
        res = self.split_interval(arr, sector_size)
        return res

    def merge_interval(self, arr):
        arr = sorted(arr)
        new_arr = []
        temp = arr[0]
        for i in range(1, len(arr)):
            start, end = arr[i]
            if start <= temp[1] < end or start == temp[1] + 1:
                temp[1] = end
                continue
            if end <= temp[1]:
                continue
            if start > temp[1]:
                new_arr.append(temp)
                temp = arr[i]
                continue
        new_arr.append(temp) # 不要忘了将最后一个区间添加
        return new_arr

    def split_interval(self, arr, s_size):
        new_arr = []
        for interval in arr:
            start, end = interval
            db1 = start // s_size  # 划分区间过程：对start整除后得到属于第几个块
            db2 = end // s_size # 划分区间过程：对end整除后得到属于第几个块
            db_num = db2 - db1 + 1 # start和end之间一共有几个块
            for i in range(0, db_num):  
                s = max(s_size * (db1 + i), start) # start整除第一个块后可能小于起始，所以要取两者较大的
                t = min(s_size * (db1 + i + 1) - 1, end) # end整除后最后一个块，可能大于end，所以要取两者较小的
                new_arr.append([s, t])
        return new_arr
```



#### 3.

```python
 '''
 题目：弹幕模拟，略复杂，代码存在一点问题，给的三个测试用例有一个没来得及调通。。。
 '''
class BulletScreenSys:
    def __init__(self):
        self.grid = [0 for _ in range(5)]

    def send(self, time: int, font_type: int, text: str) -> int:
        min_time_line = 0
        for i in range(5):
            if self.grid[i] < self.grid[min_time_line]:
                min_time_line = i
        if font_type == 0:
            if self.grid[min_time_line] <= time:
                self.grid[min_time_line] += time + len(text) + 1
                return time + 1
            else:
                if self.grid[min_time_line] <= time + 6:
                    res = self.grid[min_time_line]
                    self.grid[min_time_line] = time + len(text) + 1
                    return res
            return -1
        min_time_line_1 = 0
        for i in range(4):
            max_1 = max(self.grid[i], self.grid[i + 1])
            max_2 = max(self.grid[min_time_line_1], self.grid[min_time_line_1 + 1])
            if max_1 < max_2:
                min_time_line_1 = i
        min_time = max(self.grid[min_time_line_1], self.grid[min_time_line_1 + 1])
        if min_time <= time:
            self.grid[min_time_line_1] += time + len(text) * 2 + 1
            self.grid[min_time_line_1 + 1] = time + len(text) * 2 + 1
            return time + 1
        else:
            if min_time <= time + 6:
                res = min_time
                self.grid[min_time_line_1] = time + len(text) * 2 + 1
                self.grid[min_time_line_1 + 1] = time + len(text) * 2 + 1
                return res
        return -1    
```

