```
考试前应用号题目做一下
```



### OJ练习



**软件开发能力认证“案例开放”：http://3ms.huawei.com/km/groups/3803117/blogs/details/9595962?l=zh-cn**



------



#### 2023-10.13-1 栈模拟计算器

```python
/**
     * 题目：使用栈模拟计算器的基本操作，该计算器共有a~t 20个栈，其中共有PUSH、POP、ADD、MUL、DIV五个操作
     * PUSH(stack_name， num)：将num压入对应的栈中，若栈中大小超过32，则什么都不做
     * POP（stack_name, num）：将栈顶对应数字弹出栈
     * ADD（stack_name1，stack_name2）：将栈1和栈2栈顶数字相加，并将结果更新到栈1栈顶
     * MUL（stack_name1，stack_name2）：将栈1和栈2栈顶数字相乘，并将结果更新到栈1栈顶
     * DIV（stack_name1，stack_name2）：将栈1和栈2栈顶数字相除，并将商更新到栈1栈顶，将余数更新至栈2栈顶
     * 注意：1.所有操作均合法（不存在POP空，除0的情况）
     * 2.若计算结果大于1024，则对结果取余
     * 3.若栈为空，输出-1
     * 例1：输入：instructions = ["PSH a 8", "PSH d 3", "PSH c 3", "ADD a c", "DIV a c", "MUL d c", "POP c"]
     * 输出：[3, -1, -1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
     */
```



------



#### ✅2023-10.13-2 磁盘IO合并与拆分

在计算机系统中，跨扇区磁盘操作较慢，需要实现一个磁盘操作的合并和拆分功能，保持磁头按照地址从小到大移动，提升系统性能。

有一个磁盘系统，磁盘地址从 0 开始；每`sectorSize` 字节作为一个扇区，如第 n （从 0 开始） 个扇区的地址区间为 [sectorSize * n, sectorSize * (n+1) - 1] 。

现给出对磁盘扇区一系列读操作 `opArray`，每个操作 `opArray[i] = [startAddr, endAddr]` （左闭右闭）。请对所有读操作的**地址区间进行合并**，然后把合并后的地址区间**按扇区进行拆分**，最后按照地址**从小到大**依次输出新的地址区间（左闭右闭）。
下图对应示例1，[0, 30], [20, 50], [10, 33] 合并后的地址区间为 [0, 50]，假如 sectorSize = 32，则拆分后的输出为 [0, 31], [32, 50] 。

![img](./assets/d625eab7df863851a3c65fab8165f9e3_854x302.png@900-0-90-f.png)

**输入**

第一个参数为扇区大小 `sectorSize`，32 <= sectorSize <= 2048，且sectorSize为2的幂
第二个参数为操作列表 `opArray`，0 <= opArray.length <= 10000，0 <= opArray[i].startAddr <= opArray[i].endAddr < 2^31

**输出**

合并后的区间列表。**注意**：用例保证输出的列表大小 <= 10000

**样例****1**

输入：

```
32
[[0, 30], [10, 33], [130, 150], [151, 158], [60, 100], [130, 150], [20, 50]]
```

输出：

```
[[0, 31], [32, 50], [60, 63], [64, 95], [96, 100], [130, 158]]
```

解释：

参考上图。
对地址区间进行合并后为 [0, 50], [60, 100], [130, 158]； 注意：[130, 150] 有两次操作。
然后按照扇区大小拆分到每个扇区上，如 [60,100] 拆分到3个扇区上，为[60, 63], [64, 95], [96, 100]；
其他依次类推。

**样例****2**

输入：

```
64
[[77, 128], [130, 130], [2147483502, 2147483632], [2147483600,  2147483647]]
```

输出：

```
[[77, 127], [128, 128], [130, 130], [2147483502, 2147483519], [2147483520, 2147483583], 
[2147483584, 2147483647]]
```





**2.  题目分析**

**题目理解：**

本题可以分解为两个需求：

l 首先，区间合并。需要注意的是刚好相邻的区间合并成一个大的区间。

l 其次，区间再按扇区大小拆分。注意区间跨多个扇区的场景。

**思路解析：**

该题考察区间合并解法，在20211022力扣认证场次也有类似题目[实验室预约系统设计] https://3ms.huawei.com/km/groups/3803117/blogs/details/11204191，其中的一个解法是“打点标记法”，该解法的前提是数据规模不大。本题由于数据规模较大（opArray[i].startAddr <= opArray[i].endAddr < 2^31），参考示例2，如果采用打点方法，将会导致内存溢出，所以需采用区间合并方法。

解题可以分成以下三步：

l 第1步，首先对操作列表进行区间排序（优先按startAddr升序）；

l 第2步，其次区间合并，合并的一般方法为以当前区间的首地址和前一个区间的末尾地址进行比较，如下：

 *if (当前区间的首地址 大于 前一个区间的末尾地址 + 1) {  //既不重叠也不相邻*

  *记录一个新区间*

 *} else { // 有重叠或相邻*

  *将当前区间和前一个区间合并，即刷新前一个区间的末尾地址*

 *}*

注意：需考虑恰好相邻的场景，如示例1中的 [130, 150], [151, 158] 两个区间就是相邻的区间，合并后为 [130, 158]。

l 第3步，最后进行拆分。根据区间的startAddr和endAddr计算跨越扇区的个数，然后进行换算。需注意首个扇区和末尾扇区的边界。



```python
from typing import List, Tuple

 

class Solution:

    def io_merge(self, sector_size: int, op_array: List[Tuple[int, int]]) -> List[Tuple[int, int]]:

        op_array.sort(key=lambda x: x[0])

        merged = []

        for start, end in op_array:

            if not merged or merged[-1][1] < start - 1:

                merged.append([start, end])

            else:

                merged[-1][1] = max(merged[-1][1], end)

        sectors = []

        for start, end in merged:

            while start <= end:

                next_end = min((start // sector_size + 1) * sector_size - 1, end)

                sectors.append([start, next_end])

                start = next_end + 1

        return sectors
```



------



#### ✅2023-09.08-1. 浏览器历史记录

http://oj.rnd.huawei.com/problems/3589/details

**题目描述**

![img](./assets/63a3613e470f48558a21e28d44f80366_image.png)

打开一个浏览器，此浏览器窗口一般具备浏览历史的特性（如上图所示），请实现如下功能：

- `BrowserHistorySys(string homepage, int maxCount)` — 初始化。`homepage`作为**当前页**，并缓存到**浏览历史**中；浏览历史中最多缓存`maxCount`个网页。

- `visit(string url)` — **跳转访问**页面`url`，返回访问后浏览历史中的缓存页面数量。

  - 如果入参 url 仍是当前页，则继续浏览此页面，即：当前页不变，且浏览历史也不变；

  - 如果入参 url 不是当前页，则跳转到此 url，并把此 url 页面作为当前页； 同时清除浏览历史中原当前页的**前进记录**，再将此 url 缓存到浏览历史中。示意如图：

    ![img](./assets/bb467f0e5b714b35864e4e51b8e92c30_image.png)

    

    

    当前页为：google.com，此时跳转访问mails.huawei.com，则：
    \- 清除前进记录
    \- 跳转访问 mails.huawei.com
    \- 当前页变为 mails.huawei.com
    \- 最新当前页进入缓存浏览历史

    

  - 如果新增缓存后，浏览历史缓存页面数量超过 maxCount, 则清除浏览历史中最早的记录。

    

- `back()` — 在浏览历史中从当前页**后退**一步，返回停留页面的 url，并作为当前页。

  - 注：如果已退无可退，则不再后退，继续停留在当前页。

- `forward()` — 在浏览历史中从当前页**前进**一步，返回停留页面的 url，并作为当前页。

  - 注：如果已进无可进，则不再前进，继续停留在当前页。

**解答要求**时间限制：1000ms, 内存限制：256MB

**输入**

每行表示一个函数调用，初始化函数仅首行调用一次，累计函数调用不超过 100 次。

> homepage、url的合法集合为[0-9a-z./]，即：小写字母，数字，点和斜线。输入保证合法。
> 8 <= homepage.length, url.length < 32, 0 < maxCount < 20

**输出**

输出每个命令的执行结果

**样例**

输入样例 1 复制

```
BrowserHistorySys("w3.huawei.com", 10)
visit("google.com")
back()
forward()
forward()
visit("baidu.com")
visit("youtube.com")
back()
visit("baidu.com")
back()
visit("mails.huawei.com")
```

输出样例 1

```
null
2
"w3.huawei.com"
"google.com"
"google.com"
3
4
"baidu.com"
4
"google.com"
3
```

提示样例 1

首次操作—初始化：当前页为 “w3.huawei.com”，缓存为 [“w3.huawei.com”]，容量10
第二次操作 = visit(…)：缓存为[“w3.huawei.com”, “google.com”]，数量为 2，当前页是 “google.com”，注：无前进记录可清理
第三次操作 = back()，当前页面回到 “w3.huawei.com”
第四次操作 = forward()：当前页面又到 “google.com”
第五次操作 = forward()，进无可进，当前页仍停留在 “google.com”
第六次操作 = visit(…)：缓存变为[“w3.huawei.com”, “google.com”,”baidu.com”]，当前页为”baidu.com”
第七次操作 = visit(…)：缓存变为[“w3.huawei.com”, “google.com”,”baidu.com”,”youtube.com”]，并把当前页置为 “youtube.com”
第八次操作 = back()，当前页变为 “baidu.com”
第九次操作 = visit(…)：url和当前页相同，缓存和当前页都保持不变
第十次操作 = back(), 当前页变为”google.com”
最后操作 = visit(…)：url和当前页不同，如题干图所示

输入样例 2 复制

```
BrowserHistorySys("www.huawei.com", 3)
visit("w3.huawei.com")
visit("w4.huawei.com")
back()
visit("www.huawei.com")
visit("w5.huawei.com")
visit("w6.huawei.com")
```

输出样例 2

```
null
2
3
"w3.huawei.com"
3
3
3
```

提示样例 2

首次操作：初始化
第二次操作 = visit(…)：操作后缓存为 [www.huawei.com, w3.huawei.com]
…
第五次操作 = visit(…)：操作后缓存为 [www.huawei.com, w3.huawei.com, www.huawei.com]
第六次操作 = visit(…)：操作后缓存为 [w3.huawei.com, www.huawei.com, w5.huawei.com]，当前页面是：w5.huawei.com，注：超过缓存容量上限时，首个www.huawei.com最早，优先删除
第七次操作 = visit(…)：，缓存为 [www.huawei.com, w5.huawei.com, w6.huawei.com]，当前页面为 w6.huawei.com。注：超过缓存容量上限时，w3为当前更早，优先删除



------



#### ✅2023-08.11-1. 双遥控电路

https://3ms.huawei.com/km/groups/3803117/blogs/details/14650115?l=zh-cn

实验室对一个设备进行通断测试，实验员可以操控开关进行通断，有两种情况：
![image.png](./assets/858fe4abcf3be54c2d2b941387e10e4f_714x236.png@900-0-90-f.png)

初始时，3个开关的状态均为断开；现给定实验员操控记录的数组 records ，records[i] = [time, switchId]，表示在时刻 time 更改了开关 switchId 的状态。

开关 switchId 仅为 1、2、3，状态是**从断开变成闭合**、或**从闭合变成断开**。

测试中为了避免设备过热，若开关在时刻 time 闭合，且在 [time, time + limit) 区间内未接收到指令，则：

·     在时刻 time + limit 该开关自动变为断开；若**此时恰好**收到指令，则该开关再次变为闭合。

请返回完成最后一次操作、且所有开关状态变为断开后，设备的累计工作时长。

**示例** **1：**

输入：
records = [[0,1],[1,3],[2,2],[3,3],[4,1],[4,3]]
limit = 3

输出：5

解释：如下图所示，
在时刻 0 更改开关1，开关1切换到闭合，此时设备未工作；
在时刻 1 更改开关3，开关3切换到闭合，此时设备工作；
在时刻 2 更改开关2，开关2切换到闭合，此时设备工作；
在时刻 3 更改开关3，开关3切换到断开，虽然开关2 状态为闭合，但是开关1已自动断开，所以此时设备开始不工作；
在时刻 4 更改开关 1、3，开关1、3切换到闭合，此时设备工作；
在时刻 5，开关 2 自动断开；
在时刻 7，开关 1、3 自动断开，此后设备不再工作；
因此在 [1, 3) 和 [4, 7) 的时间段中，设备工作，返回 (3 - 1) + (7 - 4) = 5。
![image.png](./assets/8bc879678e3a6266c3215ed0a7b82f7b_509x288.png@900-0-90-f.png)

**示例** **2****：**

输入：
records = [[3,3],[4,1],[5,2],[6,1],[7,3],[8,1],[11,3]]
limit = 4

输出：6

解释：如下图所示，其中：
在时刻 7，开关 3 自动断开，但此时恰好收到指令，开关 3 再次闭合；
在时刻 11，开关 3 自动断开，但此时恰好收到指令，开关 3 再次闭合；
最终，在 [4, 6) 和 [8, 12) 的时间段中，设备工作，返回 6。
![image.png](./assets/ddfe20b2b76fd8c523666d899f308ea6_824x246.png@900-0-90-f.png)

**提示：**

·     1 <= records.length <= 10^3

·     0 <= records[i][0] <= records[i+1][0] <= 10^3

·     1 <= limit <= 10^3

·     records[i][1]仅包含 1,2,3

·     用例保证同一时刻对同一开关只有一次操作



**2.  题目分析**

**题目理解：**

题目要求根据实验员操控记录和设备的限制时间，计算设备的累计工作时长。实验员可以通过操控开关改变开关的状态，开关状态从断开变成闭合或从闭合变成断开。如果一个开关在闭合状态下、在limit时间内没有接收到指令，则该开关会自动变为断开状态。

需要注意的是，如果在开关自动断开瞬间恰好收到操作指令，开关会再次变为闭合状态。

**思路解析：**

Ø 打点法，每单位时间递增，判断每一单位时间开关状态

要想得到设备的累计工作时长，就要知道设备每个时间点是否在工作。

我们已经知道每个操作指令在什么时刻操作了哪个开关，每个开关打开后如果没有新的指令操作它，那么它将工作limit时长。

所以，我们可以考虑用打点的方法，将每个时间段对应的开关状态全部标记出来，结合示例1的数据图示如下：

![img](./assets/128149a02225dab82b79f766a87af0d2_575x218.png@900-0-90-f.png)

用二维数组记录三个开关在每个时间点的通断状态。

每当闭合一个开关SWx时，我们就对这个开关的[time, time+limit)这段时间打点标记为1，表明这段时间开关SWx处于闭合状态，其它情况标记为0。

然后，从时刻0开始遍历所有时间点，在每个时间点如果 SW1 && (SW2 || SW3) 为1，则说明这个时间段设备处于工作状态。

最后，累加所有工作时段就是设备的总工作时长。

Ø 遍历records，按每次操作的时间递进

因为每个操作指令都会更改一个开关的状态，所以我们可以在每个操作时刻，计算设备的工作时长。

注意到题目 0 <= records[i][0] <= records[i+1][0] <= 10^3 说明操作时间是升序，所以在每个操作时间点上不用管理太久的时间段、只需要计算两次操作之间的工作时长，这样迭代下去就能够求到设备的累计工作时长。

如下图下半部所示，我们在每一个操作时刻画一个泳道，泳道长度表示这个时间段设备的工作时长：

![img](./assets/c4fd19b9d54a5e7db2e1efefbba288a3_550x321.png@900-0-90-f.png)

在每次操作的时候（时刻=time、开关=switchId），开关1、2、3能够向右起作用的结束时刻设为time1、time2、time3，三个时刻再分别与下一个操作时刻取最小值（本次只处理截止到下一个操作时刻这段时间）。

设当前时刻time为左指针，则右指针=min(time1, max(time2, time3))

左右指针形成的窗口大小就是本次操作距离下一次操作之间设备的工作时段。

```python
class Solution:

    def control_circuit(self, records: List[List[int]], limit: int) -> int:

        flag = [[], [], []]

        for pre_time, switch_id in records:

            if pre_time not in flag[switch_id - 1]:

                for j in range(limit):

                    flag[switch_id - 1].append(pre_time + j)

            else:

                while pre_time in flag[switch_id - 1]:

                    flag[switch_id - 1].pop()

        together_time = set(flag[0]) & (set(flag[1]) | set(flag[2]))

        count = len(together_time)

        return count
```

该解法没有每单位时间递增，而是遍历records、按每次操作的时间递进。

Ø 创建一个名为flag的列表，其中包含三个空列表。这些列表用于存储每个开关的工作时间记录。

Ø 对于给定的records列表中的每个记录，记录包含两个值：pre_time（工作时间）和switch_id（开关ID）。

Ø 如果pre_time不在flag[switch_id - 1]列表中，表示该开关在该时间点之前没有工作过。在这种情况下，将pre_time加上0到limit-1的范围内的值，并将这些值添加到flag[switch_id - 1]列表中。

Ø 如果pre_time在flag[switch_id - 1]列表中，表示该开关在该时间点之前已经工作过。在这种情况下，从flag[switch_id - 1]列表中删除pre_time。

Ø 最后，计算同时工作的时间，即同时在开关1、开关2和开关3上工作的时间。使用集合操作符 & 和 | 来计算这些时间的交集和并集。

Ø 计算交集together_time的长度，即设备的累计工作时长。

代码简洁，易于理解。使用集合操作符来计算交集和并集，提高了代码的效率。





------



#### ✅2023-07.14-1. 容器资源分配

http://oj.rnd.huawei.com/problems/3569/details

**题目描述**

容器化是当前云化趋势下的一种重要技术，容器运行需要足够的CPU资源，请实现一种CPU分配机制，满足如下设计要求：
![image.png](./assets/28a040451e5a487c8a2a05e008890d85_image.png)

- 假设所有虚拟机的 CPU核数都为 `cpuCore` 。
- 为了满足可靠性要求，每个虚拟机上**最多部署 2 个**容器；一个容器占用一定数量的 CPU 核数，一个虚拟机上容器占用的CPU核数总和不能超过 `cpuCore` 。

现有 A、B 两个业务，每个业务都有一个或多个微服务，每个微服务独占一个容器：

- 承载业务A 的每个容器需要的CPU核数记录于 `serviceA` 中，serviceA.length 为容器数量，serviceA[i] 表示容器 i 所需的CPU核数。业务B 的信息 `serviceB` 含义同理。
- **业务A 需要支持反亲和策略**，即业务A 的任意两个容器不能运行在同一个虚拟机上；**业务B 不需要反亲和**。

请计算**最少**需要多少个虚拟机才能满足这两个业务的资源要求？

**解答要求**时间限制：800ms, 内存限制：256MB

**输入**

首行三个整数`cpuCore serviceA.length serviceB.length`
第二行是 serviceA
第三行是 serviceB

> 2 <= cpuCore <= 1000
> 1 <= serviceA.length, serviceB.length <= 10^5, 1 <= serviceA[i], serviceB[i] <= cpuCore

**输出**

一个整数，表示最少需要多少个虚拟机

**样例**

输入样例 1 复制

```
32 3 2
16 8 16
2 7
```

输出样例 1

```
3
```

提示样例 1

- 每个虚拟机的CPU核数固定为 32， 业务A 的 3 个容器的CPU核数需求为 16、8、16，业务B 的 2 个容器的CPU核数需求为 2、7 。
- 由于A业务的反亲和要求，需要虚拟机的数量至少和A业务容器数相同，即 3 个；其中一种利用 3 个虚拟机满足CPU资源需求的分配方案为：
  虚拟机1：(A:16，B:2)
  虚拟机2：(A:8，B:7)
  虚拟机3：(A:16)

> 注意：每个虚拟机最多部署2个容器

输入样例 2 复制

```
64 3 5
32 8 16
32 16 54 16 16
```

输出样例 2

```
4
```

提示样例 2

最少需要 4 个虚拟机。可以有多个分配方案，其中之一：
虚拟机1：(A:32，B:32)
虚拟机2：(A:8，B:54)
虚拟机3：(A:16，B:16)
虚拟机4：(B:16，B:16)



2. **题目分析**

**题目理解：**

题目是一个资源分配问题，即如何使用最少的虚拟机（VM）来满足两种服务（serviceA和serviceB）的CPU需求。所有虚拟机有一个固定的CPU核心数（cpuCore），每种服务都有一系列的CPU需求。如果两种服务需要的CPU核数之和不超过一个虚拟机的CPU核心数，那么这两种服务可以在同一个虚拟机上运行。

l 每个虚拟机上最多部署 2 个容器。

l 反亲和策略指的是业务A 的任意两个容器不能运行在同一个虚拟机上，即每个虚拟机上的业务组合可能是 AB、BB、A、B 四种情况，不能是AA。

这意味着任意一个serviceA[i]都需要单独占用一个虚拟机，而serviceB[j]可以和serviceA[i]拼一个虚拟机。

所以可以推断出，最后需要的虚拟机数量必定大于等于serviceA的长度的。

 

**思路解析：**

1) 计算量的估计

如果用两层循环的方法，将serviceB[j]和serviceA[i]拼一个虚拟机，拼成功后删除serviceB[j]；剩余的serviceB两两组合为一个虚拟机。

注意到 serviceA 和 serviceB 的数据规模都是10^5，两层循环暴力遍历的计算量是10^10（100亿），会超时。

解决问题的关键是如何减少计算量？

既然每个serviceA[i]都需要单独在一个虚拟机内，那么即使需要的CPU核数为1，也需要分配一个独立的虚拟机。

所以，我们可以用贪心的思想，优先将serviceA需要的虚拟机分配好，再去分配serviceB。要想尽量不浪费虚拟机的资源，需要把serviceB中CPU核数多的先用掉。于是，我们对serviceA升序、对serviceB降序排列，以样例2的数据为例，如下图所示：

![img](./assets/962e37e337c62a3914bec0db18ac1786_938x201.png@900-0-90-f.png)

每当匹配一对，就从serviceB删除匹配到的元素。注意这个时候，我们从serviceB找位置的时候，不能采用循环遍历的方式，而是要采用更高效的查找方法。

2) 二分查找

serviceA[i]先占据一个容器，现在问题就变为如何高效从serviceB中找到一个位置j，使得serviceA[i]+serviceB[j]最接近于cpuCore的值搭配为一对。

既然serviceB已经有序，我们可以用二分查找法，从serviceB找到小于等于cpuCore - serviceA[i]的最小位置。

这样，总的时间复杂度为O(nlogn)=10^5*17，大约170万的计算量。

3) 优先队列

既然需要serviceA升序、serviceB降序，而且需要从队列中增删节点，所以可以考虑用优先队列。

serviceA用小顶堆、serviceB用大顶堆，每次从队首弹出两个节点尝试组成一对：

l 如果成功，计数加1，并且从队首弹出节点

l 如果不能成功，则将大顶堆队首节点弹出后加入到小顶堆中

最后加上小顶堆的剩余长度就是最终结果。总的时间复杂度也是O(nlogn)。

4) 双指针

首先对serviceA和serviceB升序排序，从最小的serviceA和最大的serviceB开始，尝试将它们配对。如果它们的和不超过cpuCore，那么就可以在同一个虚拟机上运行；对于剩余的serviceB，从最小和最大开始，尝试将它们配对。如下图所示：

![img](./assets/e34f63e55b4157dd294fa7cb39cf35ef_939x186.png@900-0-90-f.png)

即一个指针指向serviceA，另外一个指针指向serviceB。

双指针解法，排序的时间复杂度是O(nlogn)、遍历的时间复杂度是O(n)，总的时间复杂度也是O(nlogn)。

```python

```





------



#### ✅2023-06.16-1. 单词匹配2

http://oj.rnd.huawei.com/problems/3565/details

**题目描述**

在一个字符矩阵中，可把横向或竖向**连续相邻**的字符、按顺序组成一个单词，例如下图所示的 XE、ACX、STJIIE
![image.png](./assets/2f96e8b108734200a8f71b90d3bcbd8a_image.png)

给定一个字符矩阵 charMatrix 和目标单词列表 words，请计算这个字符矩阵可以组成多少个 words 中的单词，并返回这个数量：

- 矩阵中每个格子的字符，对于同一个单词不能重复使用；在不同的单词之间可以重复使用。
- 格子字符为 `?` 表示通配符，可以匹配**任一字母**。

**解答要求**时间限制：1000ms, 内存限制：256MB

**输入**

首行两个整数 rows 和 cols，1 <= rows, cols <= 5
随后 rows 行，每行有 cols 个字符，表示给定的字符矩阵，字符矩阵仅由大写字母或字符`?`组成
最后两行输入单词数量及单词列表 words，单词仅由大写字母组成，且单词不重复，1 <= words.length <= 100，1 <= words[i].length <= 8

**输出**

一个整数，表示字符矩阵可以组成 words 中的单词数量

**样例**

输入样例 1 复制

```
3 4
ACEI
EX?I
SSTJ
8
ACX II STJIIE XE NXE ACA ACECTJ ACETJ
```

输出样例 1

```
6
```

提示样例 1

ACX, II, STJIIE, XE 这四个单词可由矩阵中连续相邻格子的字符组成。
利用通配符后，单词 NXE 可由矩阵中 ?XE 组成； 同理 ACECTJ 也可组成。
但 ACA 和 ACETJ 无法组成。

输入样例 2 复制

```
5 5
A?JFL
J?ASD
DG?OI
G??GB
A?OFC
7
A AA AAA AAAAAAAA ADJAS ADJAJDA LDSFL
```

输出样例 2

```
6
```

提示样例 2

只有 LDSFL 无法组成



------

#### 2023-06.09 - 2 至多交换一次的测试时间



有一批指示灯，放在**正方形**的测试仪器 board 中进行测试。 board[i][j] 表示仪器第 i 行 j 列位置上指示灯的型号。

现进行测试，仪器依次接收 nums 中的数字，规则如下：

l 每接收一个数字， board 中所有型号值等于该数字的指示灯都会点亮；

l 当 board 有任意一行或一列被完全点亮时，表示仪器测试完成；

l 有 1 次交换 board 中任意两盏指示灯的机会（也可以不使用）。

请问仪器**最早**能在接收第几个数字（从 1 开始计数）时完成测试？

**示例** **1****：**

输入：
nums = [6,2,2,1,7,5,7,3,4]
board = [[4,1,3],[1,2,5],[7,6,2]]

输出: 2

解释：
如下图所示方案，交换 board 中 2和7的位置，即可在接收完 nums[1] = 2 时完整点亮 board 的最后一行。
![image.png](./assets/05f93a5c560f5ca67aa0cf84771da92d_534x166.png@900-0-90-f.png)
如下交换方案也是在接收完第 2 个数字时完成：
![image.png](./assets/6d07606e6166067734a85d403ccc2d05_131x133.png@900-0-90-f.png)

假设不交换，在接收完 nums[1] 数字后，board的最后一行和中间一列只差一盏灯未点亮，因此只要交换一盏灯，即可在第 2 步完成。

**示例** **2****：**

输入：
nums = [8,9,2,7,10,1,1,1,4,5,5,3]
board = [[5,9,5,1],[1,4,2,8],[2,8,1,3],[3,1,7,2]]

输出: 6

解释：
其中一种方案如下图所示：
![image.png](./assets/c7c5dfa3116c78856d424ea0b35940f2_520x190.png@900-0-90-f.png)

**示例** **3****：**

输入：
nums = [1,2,3,4,5,6,7,8,9]
board = [[7,1,2,8],[4,8,6,3],[9,2,1,7],[4,7,6,5]]

输出: 6

解释：不需要交换任何指示灯的位置。

**提示：**

l 2 <= board.length == board[i].length <= 300，board 中的数字可能重复，且每个数字的重复个数不超过 100

l 1 <= nums.length <= 10^5, 1 <= nums[i] <= 10^5，nums 中的数字可能重复

l board 中的所有数字在 nums 中都存在，nums 中的数字在 board 中不一定存在

l 温馨提醒：暴力解法通过用例不多，请考虑高效的解法



2. **题目分析**

**题目理解：**

测试仪器由 n * n 的正方形格子组成，每个格子上的数字表示一盏灯的型号；现从一位数组 nums 中逐个接收数字，当灯的型号等于 nums[i] 时，指示灯会点亮。

求最早能在接收第几个数字（从 1 开始计数）时完成测试。

完成测试的条件是：有任意一行或一列被完全点亮时，表示仪器测试完成

注意：

l 同样的数字可能在多个格子中重复

l nums[i]和nums[j]可能相同

l 有 1 次交换 board 中任意两盏指示灯的机会（也可以不使用）：可以提前交换，也可以点亮灯过程中交换，交换本身不占用步数

l 题目说了“`board` 中的所有数字在 `nums` 中都存在”，即一定有解。

**思路解析：**

因为不知道接收第几个数字后可以完成测试，所以对nums数组进行一次遍历是少不了的。

为了方便分析时间复杂度，我们设nums的长度为m，board的边长为n。

如果每接收一个数字后，都暴力遍历所有的行和列，则时间复杂度最高可能达到 m*n^3=2.7万亿，会超时。

我们需要分析计算量，不要用暴力方法去求解。

1) 对board中的每个数字作哈希，记录数字对应的格子位置，减少计算量

以示例1为例，每个数字对应的行列位置如下表所示：

| 数字 | 对应的行列位置 |
| ---- | -------------- |
| 1    | (0,1)、(1,0)   |
| 2    | (1,1)、(2,2)   |
| 3    | (0,2)          |
| 4    | (0,0)          |
| 5    | (1,2)          |
| 6    | (2,1)          |
| 7    | (2,0)          |

这样，每当我们接收到一个数字后，就不需要遍历所有格子，而只需要遍历数字对应的行列位置。

两种极端情况：

l 所有灯的数字都相同，这个时候只要接受到这个数字后，遍历n*n的格子后就可以完成测试，时间复杂度为*O*(n^2)

l 所有灯的数字都不相同，这个时候每个数字对应的位置只有1个，可能需要遍历完整个nums数组，时间复杂度为*O*(m)

寻找影响到的格子的时间复杂度，就从*O*(n^2)减小到*O*(1)

接下来，我们就需要思考如何高效判断一行一列全部被点亮，同时利用好交换 board 中任意两盏指示灯的机会。

2) 记录每一行、每一列已经点亮的灯的数目

我们已经根据输入数字快速找到对应的格子位置，但接下来如果我们用两层循环判断哪一行、哪一列完成测试，则时间复杂度至少都是m*n^2=90亿，会超时。既然我们已经知道nums[i]影响的行和列了，我们就可以直接判断对应行或者列已点亮的灯的数量，于是我们需要用数组记录每一行、每一列已点亮的灯的数量。

判断某一行、某一列点亮灯的数量的时间复杂度，可以从O(n)减小到O(1)

3) 如何利用好交换 board 中任意两盏指示灯的机会

我们可以思考一下，用或者不用这个交换机会有什么不同？思考之后，我们可以发现完成测试有两种情况：

l 某一行或者某一列， 所有灯都亮了。

l 某一行或者某一列，还差一盏灯， 其他行或列的位置还有亮的灯，我们就可以替换了并终止。

![img](./assets/a9359719537807fe165e4ce909c16023_106x106.png@900-0-90-f.png)

如上图所示，当示例1中已经接收到两个数字（分别是6和2）后，第2行（最底下那行）已点亮的灯数为2，但是总的亮灯数为3，此时我们把这个交换机会用掉就可以完成测试。所以，我们这样利用交换机会：

l 当某行或某列已点亮的灯数为 n-1时，如果此时总的亮灯数大于等于n，那么交换后这行或这列所有灯将全部被点亮。

 

n^2等于9万，m等于10万，两者取较大值，所以最优的时间复杂度是*O*(m)。



```python
import collections
from typing import List


class Solution:
    def earliest_completed_test(self, nums: List[int], board: List[List[int]]) -> int:

        len_nums, len_board = len(nums), len(board)
        number_loc = collections.defaultdict(list)

        for i in range(len_board):
            for j in range(len_board):
                number_loc[board[i][j]].append((i, j))

        number_to_light_row, number_to_light_col = [len_board] * len_board, [len_board] * len_board

        total_light = 0
        res = 1
        for num in nums:
            if number_loc.get(num):
                for x, y in number_loc[num]:

                    number_to_light_row[x] -= 1
                    number_to_light_col[y] -= 1

                    total_light += 1
                    if number_to_light_row[x] == 0 or number_to_light_row[y] == 0:
                        return res
                    if number_to_light_row[x] == 1 or number_to_light_col[y] == 1 and total_light >= len_nums:
                        return res

            number_loc[num].clear()
            res += 1

        return -1


# nums = [6, 2, 2, 1, 7, 5, 7, 3, 4]
# board = [[4, 1, 3], [1, 2, 5], [7, 6, 2]]
nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]
board = [[7, 1, 2, 8], [4, 8, 6, 3], [9, 2, 1, 7], [4, 7, 6, 5]]
print(Solution().earliest_completed_test(nums, board))
```

该解法用dict记录每个数字对应的位置信息。

Ø 首先通过函数 init_num_to_loc 将 board 中每个数字对应的位置记录下来，存储在一个字典 num_to_loc 中。

Ø 然后通过函数 init_row_col 初始化两个列表 row_n 和 col_n，分别表示每行和每列未点亮的灯数，初始值都为n。

Ø 接着遍历 nums 列表中的每个数字：

l 找到它在网格中的位置，更新 row_n 和 col_n 列表中对应行和列的数字个数，并判断该行或该列是否已经填满，如果是，则返回当前步数 t。

l 如果该行或该列还差一个数字就能点亮所有灯，将 exist 标记为 True，意思是下一步就可以完成测试。

l 如果 exist 为 True，且已经点亮的灯数 total 大于等于 bn，则返回当前步数 t。

l 最后将 num_to_loc 中该数字对应的位置清空，步数 t 加 1。

代码简洁易懂，时间复杂度为 *O*(m)。





------

#### 2022-09.16-2 光通信激光穿透材料测试





------

#### 2022-05.12 - 2  简易文件读写

请实现一个简易的文本文件读写系统，提供如下文件操作功能：

·     `TextFileSys()` -- 系统初始化，此时无任何文件

·     `open(string filename, string mode)` -- 打开或新建文件。打开模式 mode 仅为 r 、 r+ 、w 、w+ 、a 、a+ ：

o  文件 filename 不存在：仅当 mode 为 r 或 r+ 时失败，其它模式下会新建此文件并打开成功。

o  文件 filename 已存在：处于未打开状态时，打开成功；处于已打开状态时，打开失败。

成功打开后，按下表处理，并返回 0； 失败返回 -1 。

| **内容处理规则**           | r    | r+   | w    | w+   | a    | a+   |
| -------------------------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 打开时是否清空内容         | n    | n    | y    | y    | n    | n    |
| 打开时位置指示器的初始位置 | 开头 | 开头 | 末尾 | 末尾 | 末尾 | 末尾 |
| 打开后是否可读             | y    | y    | n    | y    | n    | y    |
| 打开后是否可写             | n    | y    | y    | y    | y    | y    |

·     `close(string filename)` -- 关闭文件 filename

o  若文件处于打开状态，则关闭该文件、并返回 0； 否则，返回 -1 。

·     `write(string filename, string content)` -- 往文件 filename 中写入内容 content

o  若文件处于打开状态且可写，则按照「内容处理规则」，在位置指示器的当前位置写入content内容，返回写入后文件内容的长度；否则，返回 -1 。

o  写入后，位置指示器移动到本次写入内容的末尾。

·     `readAll(string filename)` -- 读出文件 filename 中的全部内容

o  若文件处于打开状态且可读，则按照「内容处理规则」，读出文件全部内容并返回；当内容为空时，返回字符串`null`；否则，返回字符串 `error` 。

o  readAll 操作不改变位置指示器。

r: 以只读方式打开已存在的文件; r+: 以读写方式打开一个已存在的文件。
w: 以只写方式打开或新建一个文件。 w+: 以读写方式打开或新建一个文件。
a：以追加方式打开或新建一个文件，用于写。 a+: 以追加方式打开或新建一个文件，用于读写。

输入

首行一个整数 num，表示文件操作的个数，1 <= num <= 100
接下来 num 行，每行一个文件操作，格式为 `操作``=``参数``1 ``参数``2 …`

filename 仅为字母和数字，1 <= filename.length <= 10
content 仅为不含空格的可见字符，1 <= content.length <= 10

输出

逐行输出这 num 个操作的返回值

样例1

输入：

```
7
TextFileSys
open=file1 w
open=file2 a
write=file1 engineer
close=file1
readAll=file1
readAll=file2
```

输出：

```
null
0
0
8
0
error
error
```

解释：

第四条命令 write=file1 engineer，往文件file1 写入内容 engineer，返回写入后文件内容长度 8 。
第六条命令 readAll=file1 执行时，file1已关闭，因此返回 error 。
第七条命令 readAll=file2 执行时，因为文件以 a 模式打开，不能读，返回 error

样例2

输入：

```
11
TextFileSys
open=f a
write=f hello
close=f
open=f w+
readAll=f
write=f how
close=f
open=f a+
write=f areyou
readAll=f
```

输出：

```
null
0
5
0
0
null
3
0
0
9
howareyou
```

解释：

第五条命令： w+ 模式打开文件后，内容被清空，因此第六条命令 readAll 返回字符串 null 。
第九条命令： a+ 模式打开后，位置指示器位于文件内容结尾；第十条命令，新写入内容追加在原内容后面。最后的命令 readAll，返回文件全部内容 howareyou

样例3

输入：

```
9
TextFileSys
open=f w+
write=f engineer
close=f
open=f r+
write=f hello
readAll=f
write=f world
readAll=f
```

输出：

```
null
0
8
0
0
8
helloeer
10
helloworld
```

解释：

r+ 模式打开后，位置指示器位于文件内容开头，新写入内容会从前往后覆盖内容，未被覆盖的内容保持不变：

·     write=f hello 写入后，已有内容从 engineer 变成 helloeer，指示器指向 o 后面的位置；

·     write=f world 再写入时，覆盖了 eer ，写入后最终变成 helloworld



**2.  题目分析**

**题目理解：**

该题要求程序模拟对文件的读写操作，与真实的文件系统操作类似，但不需要实际创建和读写文件。除构造函数外，一共有四个接口：

l 打开或新建文件

l 关闭文件

l 对某个文件写内容

l 读某个文件的所有内容

 

参考题目中的表格，需注意点如下：

1） open接口

a)   系统中一开始不存在任何文件，需要通过w 、w+ 、a 、a+四种模式之一来创建文件，后续才能对该文件进行读写操作；

b)   使用w 、w+两种模式打开文件时，会清空文件已经存在的内容；

c)   文件指示器在本题中主要是影响写数据内容的位置，注意使用“r+”模式打开时，可对文件进行写内容，且打开时未清空内容，并将文件指示器移到了开头；读数据内容不改变也不依赖文件指示器的位置。

2） write接口：文件指示器的位置不一定在末尾，写入时，从指示器位置开始写入内容，即：覆写已有内容、续写超出部分，而不是插入的方式写入，可参考示例3。

 

**思路解析：**

1） 设计建模：根据上面的题目理解，每个文件会涉及到文件名称、打开状态、读写标识、文件指示器的位置、文件内容，可以用一个单独的类/结构体保存；而文件管理系统，会操作多个文件，包含一个文件对象字典或列表。

 ![img](./assets/4afadb3ff140d68f583110f9645806ef_425x214.png@900-0-90-f.png)

 

2） 实现方法：我们可以使用一个字典来存储文件对象，字典的键为文件名，值为一个元组（内容即上图文件对象中定义的属性）。

打开文件时，将新建的文件对象，按照不同模式初始化后，存储到字典中。

关闭文件时，只要刷新“打开状态”即可，不能在字典中删除。

读文件时，判断不是w或a模式，就读出文件的所有内容。

写文件时，需要注意文件指示器的当前位置，判断不是r模式，就写入内容。

```py
import sys

 

class TextFileSys:

    def __init__(self):

        self.file_manager = dict()

    

    def init_handle(self, handle):

        handle['isopen'] = True

        handle['content'] = '' if mode in ('w', 'w+') else handle.get('content', '')

        handle['location'] = 0 if mode in ('r', 'r+') else len(handle.get('content', ''))

        handle['readable'] = False if mode in ('w', 'a') else True

        handle['writeable'] = False if mode in ('r') else True

 

    def open(self, filename: str, mode: str) -> int:

        handle = self.file_manager.get(filename, dict())

        if handle.get('isopen', False):

            return -1

        if mode == 'r' or mode == 'r+':

            if not handle:

                return -1

        self.init_handle(handle)

        self.file_manager[filename] = handle

        return 0

 

    def close(self, filename: str) -> int:

        handle = self.file_manager.get(filename, dict())

        if not handle:

            return -1

        if handle.get('isopen', False):

            handle['isopen'] = False

            return 0

        return -1

 

    def write(self, filename: str, content: str) -> int:

        handle = self.file_manager.get(filename, dict())

        if handle.get('isopen', False) and handle.get('writeable', False):

            handle['content'] = handle['content'][0 : handle['location']] + content + \

                handle['content'][handle['location'] + len(content) : ]

            handle['location'] += len(content)

            return len(handle['content'])

        return -1

 

    def read_all(self, filename: str) -> str:

        """在此添加你的代码"""

        handle = self.file_manager.get(filename, dict())

        if handle.get('isopen', False) and handle.get('readable', False):

            return handle['content'] if handle['content'] else 'null'

        return 'error'

 

if __name__ == "__main__":

    num = int(sys.stdin.readline().strip())

    sys.stdin.readline()

    print("null")

    function = TextFileSys()

    for _ in range(num - 1):

        cmd, value = sys.stdin.readline().strip().split("=")

        paras = value.strip().split(' ')

        filename = paras[0]

        if cmd == "open":

            mode = paras[1]

            print(function.open(filename, mode))

        elif cmd == "write":

            content = paras[1]

            print(function.write(filename, content))

        elif cmd == "close":

            print(function.close(filename))

        elif cmd == "readAll":

            print(function.read_all(filename))

        else:

            print("error input")
```

使用了两级字典来保存文件对象，第1层字典file_manager的key为文件名，第2层字典handle，使用key如'isopen'、'content'、'location'、'readable'、'writeable'分别记录了文件的打开状态、文件内容、文件指示器位置、可读写标识。对于handle，还可以考虑使用类或数组来定义，当属性较多时，对于同一维度的属性，可以采用类方式进行二次聚合。



------

#### ✅2022-01.21-1 仓库管理系统

请设计一个仓库管理系统，实现如下功能：

·     StorageSystem(int coldStorageNum, int coldStoragePrice, int normalStorageNum, int normalStoragePrice, int delay) — 初始化仓库信息。

o  仓库有冷藏和常温两种类型的储藏室，初始化其对应的数量和每天租赁价格；

o  若客户租赁过期且超出 delay 天后，依旧未提取货物，该储物区将被清空；

·     store(int date, int storageId, int storageType, int storageDays) — 在日期 date 为存单 storageId 租赁 storageType 类型的**一个**储藏室，并存放物品 storageDays 天。

o  若有空间则存储成功，则需预付 storageDays 天的费用（按照实际使用储藏室类型进行计算：天数 * 每日租赁价格），返回该费用；

§ 当常温储藏室空间不足时，可使用空闲的冷藏储藏室存储；反之不可以；

§ date 为「租赁起始日期」，日期超过 date + storageDays 时开始过期

o  若无空间则不做任何处理，并返回 -1。

系统保证 storageId 参数全局唯一。storageType 为 0 表示冷藏， 1 表示常温。

·     retrieve(int date, int storageId) — 在日期 date ，客户取出存单 storageId （存单一定存在且未被提取）对应的物品：

o  若存单未过期时，则取出物品，并返回 0；

o  若存单过期但未超出 delay 天，则取出物品，并返回需要补交的费用（实际延迟天数 * 每日价格），实际延迟天数 = date - (「租赁起始日期」+ storageDays)；

o  若存单过期且已超出 delay 天（日期超过 「租赁起始日期」+ storageDays + delay ）时，则物品已被清空、取出失败，并返回 -1。

·     query(int date) — 请返回截止日期 date 时 3 种状态的存单数量序列，依次为：物品已成功取出、物品未取仍在仓库中、物品被清空的存单数量。

**注意**：保证函数 store、retrieve、query 的日期 date 参数按输入顺序非严格递增；

**示例** **1****：**

输入：
["StorageSystem","store","retrieve","query"]
[[2,2,1,1,2],[0,1,0,2],[3,1],[3]]

输出：[null,4,2,[1,0,0]]

解释：
StorageSystem obj = StorageSystem(2,2,1,1,2); // 初始化仓库，2 个冷藏室（每天价格 2）和 1 个常温室（每天价格 1），货物最多可以延期 2 天；
obj.store(0,1,0,2); // 在日期 0，存单 1 预定冷藏室 2 天；由于存在空闲冷藏室，返回支付款项 2*2 = 4
obj.retrieve(3,1); // 在日期 3 提取存单 1 对应物品。实际延迟天数为 1 = 3 - (0 + 2)，返回补交费用 2*1 = 2 ；因过期但未超出 2 天，不会被清空，
obj.query(3); // 当前物品已成功取出、物品未取仍在仓库中、物品被清空的存单各有 1 份、0 份、0 份，返回 [1,0,0]
注：输出中的 null 表示此对应函数无输出（其中：C 的构造函数有返回值，但是也是无需输出）

**示例** **2****：**

输入：
["StorageSystem","query","store","store","store","query","store","retrieve","store","query","query","retrieve"]
[[2,2,1,3,2],[0],[0,21,1,3],[1,22,1,4],[1,23,0,2],[1],[4,26,1,2],[5,21],[6,24,0,7],[7],[8],[9,22]]

输出：[null,[0,0,0],9,8,4,[0,3,0],-1,6,14,[1,2,1],[1,1,2],-1]

解释：
StorageSystem obj = StorageSystem(2,2,1,3,2); // 初始化仓库，2 个冷藏室（每天价格 2）和 1 个常温室（每天价格 3），货物最多可以延期 2 天；
obj.query(0); // 返回 [0,0,0]
obj.store(0,21,1,3); // 返回支付款项 3*3=9
obj.store(1,22,1,4); // 日期 1，存单编号 22，预定常温室 4 天；由于无未租赁的常温室，租赁冷藏室，返回 4*2=8
obj.store(1,23,0,2); // 返回支付款项 2*2=4
obj.query(1); // 返回 [0,3,0]
obj.store(4,26,1,2); // 由于无未租赁的常温室和冷藏室，返回 -1
obj.retrieve(5,21); // 此时存单 21 延迟天数为 2 = 5 - (0 + 3)，需补交费用为 2*3=6
obj.store(6,24,0,7); // 由于存单 23 过期且超出 2 天未提取（6 > 1 + 2 + 2），物品被清空。因此存在未租赁的冷藏室，返回 7*2=14
obj.query(7); // 返回 [1,2,1]
obj.query(8); // 由于存单 22 过期且超出 2 天未提取使物品清空，返回 [1,1,2]
obj.retrieve(9,22); // 此时存单 22 已被清空，返回 -1;
注：输出中的 null 表示此对应函数无输出（其中：C 的构造函数有返回值，但是也是无需输出）

**提示：**

1 <= store, retrieve, query 累计操作数 <= 1000

1 <= coldStorageNum, normalStorageNum <= 100

1 <= coldStoragePrice, normalStoragePrice <= 100

0 <= storageId <= 1000

0 <= date <= 10^4

1 <= delay, storageDays <= 100

0 <= storageType <= 1





2. **题目分析**

**题目理解：**

设计一个仓库管理系统，加上构造函数共4个接口。

每个存单从租赁开始，日期有三种可能状态：

以示例1为例：// 在日期 0，存单 1 预定冷藏室 2 天，货物最多可以延期 2 天(delay=2)

| 日期 | 0                 | 1    | 2      | 3          | 4          | 5                       |
| ---- | ----------------- | ---- | ------ | ---------- | ---------- | ----------------------- |
| 说明 | 开始租赁，预定2天 |      | 到期日 | 延迟天数=1 | 延迟天数=2 | 租赁过期且超出 delay 天 |

租赁过期且超出 delay 天后，依旧未提取货物，该储物区将被清空，例如在日期5这天。

本题有两个难点：

l 常温储藏室空间不足时，常温和冷藏室的转换

l 找到时机处理物品被清空的存单

**解题思路：**

1) 设计建模

![img](./assets/d48dae843aee6724976f6b05656998b0_564x139.png@900-0-90-f.png)

在编码之前，先设计建模以便理清楚有哪些对象、对象之间的关系，这样不至于写到一半代码发现数据结构设计错了导致返工。

需要记录两类储藏室价格和数量，冷藏室价格、常温区价格、dealy……这些属性属于仓库管理系统，所以不需要保存到单独的类中。

每个存单对象，最好用一个单独的类/结构体保存，这样更好维护。

2) 盘点存单的时机

因为要求“若客户租赁过期且超出 delay 天后，依旧未提取货物，该储物区将被清空”，所以需要找一个时机来处理物品被清空的存单。

经过分析我们可以发现：由于并没有一个定时器机制，只有在三个操作接口中进行。

多次调用时，已经清理过的存单不能再次清理，所以清理后需要记录。

3) 统计3 种状态的存单数量的方法

可以分为记录法和遍历统计法。

记录法，又可以细分为计数法和容器统计法；前者是用整数变量实时计数，后者是将存单id加入到容器中再返回容器的size()。



```python
class Entity:
    def __init__(self, date, storageId, storageType, storageDays, price, cost):
        self.date = date
        self.storageId = storageId
        self.storageType = storageType
        self.storageDays = storageDays
        self.price = price
        self.cost = cost


class StorageSystem:
    def __init__(self, cold_storage_num: int, cold_storage_price: int, normal_storage_num: int,
                 normal_storage_price: int, delay: int):

        self.store_info = {
            0: [cold_storage_num, cold_storage_price],  # cold number, cold price
            1: [normal_storage_num, normal_storage_price]
        }
        self.delay = delay
        self.success_put = {}
        self.instorage = {}
        self.cleared = {}

    def store(self, date: int, storage_id: int, storage_type: int, storage_days: int) -> int:
        # store里面update是为了time时把位置空出来 让新存的有地方
        self.update_storage(date)
        if storage_type == 0:  # cold
            if self.store_info[0][0] > 0:
                self.store_info[0][0] -= 1
                cost = storage_days * self.store_info[0][1]
                self.instorage[storage_id] = Entity(date, storage_id, storage_type, storage_days, self.store_info[0][1],
                                                    cost)
                return cost
            return -1
        else:  # noranal
            if self.store_info[1][0] > 0:
                self.store_info[1][0] -= 1
                cost = cost = storage_days * self.store_info[1][1]
                self.instorage[storage_id] = Entity(date, storage_id, storage_type, storage_days, self.store_info[1][1],
                                                    cost)
                return cost
            elif self.store_info[1][0] == 0 and self.store_info[0][0] > 0:
                self.store_info[0][0] -= 1
                cost = storage_days * self.store_info[0][1]
                self.instorage[storage_id] = Entity(date, storage_id, 0, storage_days, self.store_info[0][1], cost)
                return cost
            return -1

    def retrieve(self, date: int, storage_id: int) -> int:
        # retrieve指定了对应的订单处理 本身会更新与本次操作有关的三种状态存单的数量 不用额外去全量update
        if not self.instorage.get(storage_id):  # 可能已经被拿出去了
            return -1
        entity = self.instorage.pop(storage_id)
        self.store_info[entity.storageType][0] += 1
        vaild_date = entity.date + entity.storageDays
        entire_date = vaild_date + self.delay
        # 未过期
        if date <= vaild_date:
            self.success_put[storage_id] = entity
            return 0
        # 过期，但是没有超出delay
        elif vaild_date < date <= entire_date:
            self.success_put[storage_id] = entity
            need_to_cost = (date - vaild_date) * entity.price
            return need_to_cost
        # 过期且超出delay
        elif date > entire_date:
            self.cleared[storage_id] = entity
            return -1

    def query(self, date: int):
        # query里面update是为了获取最新time的三种状态存单的数量
        self.update_storage(date)
        return len(self.success_put), len(self.instorage), len(self.cleared)

    def update_storage(self, date):

        for id, entity in list(self.instorage.items()):
            if entity.date + entity.storageDays + self.delay < date:
                del self.instorage[id]
                self.store_info[entity.storageType][0] += 1
                self.cleared[id] = entity


if __name__ == '__main__':
    # test1
    # obj = StorageSystem(2, 2, 1, 1, 2)
    # print(obj.store(0, 1, 0, 2))
    # print(obj.retrieve(3, 1))
    # print(obj.query(3))

    # test2
    obj = StorageSystem(2, 2, 1, 3, 2)
    print(obj.query(0))
    print(obj.store(0, 21, 1, 3))
    print(obj.store(1, 22, 1, 4))
    print(obj.store(1, 23, 0, 2))
    print(obj.query(1))
    print(obj.store(4, 26, 1, 2))
    print(obj.retrieve(5, 21))
    print(obj.store(6, 24, 0, 7))
    print(obj.query(7))
    print(obj.query(8))
    print(obj.retrieve(9, 22))
```

