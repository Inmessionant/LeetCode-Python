```
考试前应用号题目做一下
```



### OJ练习



- **典型试题开放列表：https://3ms.huawei.com/km/groups/3803117/blogs/details/9606176?l=zh-cn**
- **软件开发能力认证“案例开放”：http://3ms.huawei.com/km/groups/3803117/blogs/details/9595962?l=zh-cn**
- **软件认证：https://oj.rnd.huawei.com/problems/all （优先困难 -> 中等）**





#### 2023-10.13-2. 磁盘IO合并与拆分



**题目描述**

在计算机系统中，跨扇区磁盘操作较慢，需要实现一个磁盘操作的合并和拆分功能，保持磁头按照地址从小到大移动，提升系统性能。

有一个磁盘系统，磁盘地址从 0 开始；每`sectorSize` 字节作为一个扇区，如第 n （从 0 开始） 个扇区的地址区间为 [sectorSize *n, sectorSize* (n+1) - 1] 。

现给出对磁盘扇区一系列读操作 `opArray`，每个操作 `opArray[i] = [startAddr, endAddr]` （左闭右闭）。请对所有读操作的**地址区间进行合并**，然后把合并后的地址区间**按扇区进行拆分**，最后按照地址**从小到大**依次输出新的地址区间（左闭右闭）。
下图对应示例1，[0, 30], [20, 50], [10, 33] 合并后的地址区间为 [0, 50]，假如 sectorSize = 32，则拆分后的输出为 [0, 31], [32, 50] 。
![img](./assets/b0a62b8a9b624bb5a1710ffedce27bba_image.png)

**解答要求**时间限制：1000ms, 内存限制：256MB

**输入**

第一个参数为扇区大小 `sectorSize`，32 <= sectorSize <= 2048，且sectorSize为2的幂
第二个参数为操作列表 `opArray`，0 <= opArray.length <= 10000，0 <= opArray[i].startAddr <= opArray[i].endAddr < 2^31

**输出**

合并后的区间列表。**注意**：用例保证输出的列表大小 <= 10000

```python
'''
http://oj.rnd.huawei.com/problems/3599/details

输入样例 1 
32
[[0, 30], [10, 33], [130, 150], [151, 158], [60, 100], [130, 150], [20, 50]]

输出样例 1
[[0, 31], [32, 50], [60, 63], [64, 95], [96, 100], [130, 158]]

提示样例 1
对地址区间进行合并后为 [0, 50], [60, 100], [130, 158]； 注意：[130, 150] 有两次操作。
然后按照扇区大小拆分到每个扇区上，如 [60,100] 拆分到3个扇区上，为[60, 63], [64, 95], [96, 100]；
其他依次类推。


输入样例 2
64
[[77, 128], [130, 130], [2147483502, 2147483632], [2147483600,  2147483647]]

输出样例 2
[[77, 127], [128, 128], [130, 130], [2147483502, 2147483519], [2147483520, 2147483583], [2147483584, 2147483647]]
'''
class Solution:
    def io_merge(self, sector_size: int, op_array: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
        if not op_array:
            return []
        op_array.sort(key=lambda x: x[0])
        array_list = [list(array) for array in op_array]
        temp = [array_list[0]]
        for i in range(1, len(array_list)):
            if array_list[i][0] > temp[-1][1] + 1:
                temp.append(array_list[i])
            else:
                if temp[-1][1] < array_list[i][1]:
                    temp[-1][1] = array_list[i][1]
        res = []
        for array in temp:
            times = array[1] // sector_size - array[0] // sector_size
            if times == 0:
                res.append(array)
            else:
                dev = array[0] // sector_size
                res.append([array[0], (dev + 1) * sector_size - 1])
                temp_num = 0
                for _ in range(times - 1):
                    temp_num += 1
                    res.append([(dev + temp_num) * sector_size, (dev + 1 + temp_num) * sector_size - 1])
                res.append([(dev + 1 + temp_num) * sector_size, array[1]])
        return res
```

```python
from typing import List, Tuple


class Solution:
    def io_merge(self, sector_size: int, op_array: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
        if not op_array:
            return []
        arr = self.merge_interval(op_array)
        res = self.split_interval(arr, sector_size)
        return res

    def merge_interval(self, arr):
        arr = sorted(arr)
        new_arr = []
        temp = arr[0]
        for i in range(1, len(arr)):
            start, end = arr[i]
            if start <= temp[1] < end or start == temp[1] + 1:
                temp[1] = end
                continue
            if end <= temp[1]:
                continue
            if start > temp[1]:
                new_arr.append(temp)
                temp = arr[i]
                continue
        new_arr.append(temp) # 不要忘了将最后一个区间添加
        return new_arr

    def split_interval(self, arr, s_size):
        new_arr = []
        for interval in arr:
            start, end = interval
            db1 = start // s_size  # 划分区间过程：对start整除后得到属于第几个块
            db2 = end // s_size # 划分区间过程：对end整除后得到属于第几个块
            db_num = db2 - db1 + 1 # start和end之间一共有几个块
            for i in range(0, db_num):  
                s = max(s_size * (db1 + i), start) # start整除第一个块后可能小于起始，所以要取两者较大的
                t = min(s_size * (db1 + i + 1) - 1, end) # end整除后最后一个块，可能大于end，所以要取两者较小的
                new_arr.append([s, t])
        return new_arr
```



#### 2023-09.08-1. 浏览器历史记录

```python

```



#### 2023-09.08-2. 树状选中变更

```python

```



