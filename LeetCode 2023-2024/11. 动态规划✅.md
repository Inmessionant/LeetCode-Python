

# 基础理论



动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的；

所以动态规划中每一个状态一定是由上一个状态推导出来的，**这一点就区分于贪心**，贪心没有状态推导，而是从局部直接选最优的；

例如：有`N`件物品和一个最多能背重量为`W` 的背包。第i件物品的重量是`weight[i]`，得到的价值是`value[i] `。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大；

动态规划中`dp[j]`是由`dp[j-weight[i]]`推导出来的，然后取`max(dp[j], dp[j - weight[i]] + value[i])`；

但如果是贪心呢，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系；

所以贪心解决不了动态规划的问题；



**解题步骤：**

- **确定dp数组以及下标的含义；**
- **确定递推公式；**
- **dp数组如何初始化；**
- **确定遍历顺序；**



### ✅[斐波那契数](https://leetcode.cn/problems/fibonacci-number/)

```python
class Solution:
    def fib(self, n: int) -> int:
		# 特殊情况
        if n < 2:  return n
        # 1.dp[i]的定义为：第i个数的斐波那契数值是dp[i]
        dp = [0 for _ in range(n + 1)]
        # 3.dp数组如何初始化,题目中把如何初始化也直接给我们了
        dp[0], dp[1] = 0, 1
        # 确定遍历顺序,从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的
        for i in range(2, n + 1):
            dp[i] = dp[i - 1] + dp[i - 2]  # 2.确定递推公式,题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2]

        return dp[-1]
```



### ✅[爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

```Python
# m阶爬楼梯是完全背包问题

class Solution:
   # 2阶爬楼梯
    def climbStairs(self, n: int) -> int:

        if n <= 2: return n
        # 1.dp[i]： 爬到第i层楼梯，有dp[i]种方法
        dp = [0 for _ in range(n + 1)] 
        # 3.dp数组初始化,dp[1] = 1 dp[2] = 2
        dp[1], dp[2] = 1, 2
        # 4.根据递推公式确立遍历顺序
        for i in range(3, n + 1):
            dp[i] = dp[i - 1] + dp[i - 2] # 2.递推公式
        
        return dp[-1]
```



### [✅使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        # 1.dp定义：到第i个台阶所花费的最小体力为dp[i]，len(cost) - 1位置再跳一级才是楼顶，因此楼顶位置idx=len(cost)
        dp = [0 for _ in range(len(cost) + 1)]
        # 3.初始化，你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯，只有跳到时候才花费体力
        dp[0], dp[1] = 0, 0 

        for i in range(2, len(cost) + 1): # 4.确定遍历顺序
            dp[i] = min(dp[i-1] + cost[i - 1], dp[i-2] + cost[i - 2]) # 2.递推公式，i位置是由i - 1位置再花费cost[i - 1]跳上去，或者由i - 2位置再花费cost[i - 2]跳上去
        
        return dp[-1]
```



### ✅[不同路径](https://leetcode-cn.com/problems/unique-paths/)

```Python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # 1.dp[i][j]表示从(0,0)出发,到达(i,j)有dp[i][j]条不同的路径
        dp = [[1 for _ in range(n)] for _ in range(m)] # 3.dp数组初始化，dp[0][i], dp[i][0]都是1
        # 4.根据递推公式，确定从左上到右下的遍历顺序
        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] # 2.dp[i][j]只有左边和上边两条方向进入
        
        return dp[-1][-1]
```



### ✅[不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

```Python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:

        m, n = len(obstacleGrid), len(obstacleGrid[0])
        
        if obstacleGrid[0][0] == 1 or obstacleGrid[m -1][n - 1] == 1:
            return 0 # 开始或者结束位置有障碍物
      
        # 1.dp[i][j] 表示从(0,0)出发到(i,j)位置有多少条不同的路径
        dp = [[0 for _ in range(n)] for _ in range(m)]
        # 3.dp数组初始化，只有没有障碍物才是1，一旦遇到有障碍物，这个位置及以后都是0
        for i in range(m):
            if obstacleGrid[i][0] == 1:
                break
            else:
                dp[i][0] = 1
        
        for j in range(n):
            if obstacleGrid[0][j] == 1:
                break
            else:
                dp[0][j] = 1
        # 4.确定遍历顺序，从左上到右下
        for i in range(1, m):
            for j in range(1, n):
                if obstacleGrid[i][j] == 0: # 2.递推公式，但是要保证没有障碍物，有障碍物这个位置dp[i][j]=0
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        
        return dp[-1][-1]
```



### ✅[最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

```Python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:

        m, n = len(grid), len(grid[0])

        for i in range(1, m):
            grid[i][0] = grid[i - 1][0] + grid[i][0]
        
        for i in range(1, n):
            grid[0][i] = grid[0][i - 1] + grid[0][i]
        
        for i in range(1, m):
            for j in range(1, n):
                grid[i][j] = min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j]
        
        return grid[-1][-1]
```



### ✅[整数拆分](https://leetcode-cn.com/problems/integer-break/)

```python
class Solution:
    def integerBreak(self, n: int) -> int:
        # 1. dp[i]表示分拆数字i，得到的最大乘积
        dp = [0 for _ in range(n + 1)]
        # 3.dp初始化,2 <= n <= 58,dp至少有
        dp[0], dp[1], dp[2] = 0, 0, 1

        # 遍历顺序
        for i in range(3, n + 1):
            for k in range(i + 1):
            # 假设对正整数 i 拆分出的第一个正整数是 j（1 <= j < i），则有以下两种方案：
            # 1) 将 i 拆分成 j 和 i−j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是 j * (i-j)
            # 2) 将 i 拆分成 j 和 i−j 的和，且 i−j 继续拆分成多个正整数，此时的乘积是 j * dp[i-j]
                dp[i] = max(k * (i - k), dp[i - k] * k) # 2. 递推公式:一个是拆分成 k 个(k = 2)，j * (i - j) 直接相乘; 一个是拆分成k个(k > 2) j * dp[i - j]，相当于是拆分(i - j)
        
        return dp[-1]
```



### ✅[三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

```python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:

        for i in range(len(triangle) - 2, -1, -1):
            for j in range(len(triangle[i])):
                triangle[i][j] = triangle[i][j] + min(triangle[i + 1][j], triangle[i + 1][j + 1])
        
        return triangle[0][0]
```



### ✅[下降路径最小和  II](https://leetcode-cn.com/problems/minimum-falling-path-sum-ii/)

```python
class Solution:
    def minFallingPathSum(self, arr: List[List[int]]) -> int:
      
        m, n = len(arr), len(arr[0])

        for i in range(1, m):
            min1 = min(arr[i - 1])
            min1idx = arr[i - 1].index(min1)
            arr[i - 1].remove(min1)
            min2 = min(arr[i - 1])

            for j in range(n):
                if j == min1idx:
                    arr[i][j] += min2
                else:
                    arr[i][j] += min1

        return min(arr[-1])
```



#### ✅[交错字符串](https://leetcode-cn.com/problems/interleaving-string/)

https://leetcode-cn.com/problems/interleaving-string/solution/dong-tai-gui-hua-zhu-xing-jie-shi-python3-by-zhu-3/

```python
class Solution:
    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:

        lens1, lens2, lens3 = len(s1), len(s2), len(s3)
        # 若len1+len2!=len3，表示一定不能构成交错字符串，返回False
        if (lens1 + lens2) != lens3:
            return False
        # 1.使用dp[i][j]dp[i][j]表示s1的前i个字符和s2的前j个字符是否能构成s3的前i+j个字符
        dp = [[False for _ in range(lens2 + 1)] for _ in range(lens1 + 1)]
        # 3.初始化：dp[0][0]一定是True
        dp[0][0] = True
        # 3.初始化第一列 dp[i][0]，遍历第一列，遍历区间 [1,len1+1)，表示s1的前i位是否能构成s3的前i位：前 i−1位可以构成s3的前i−1位且s1的第i位（s1[i−1]）等于s3的第i位（s3[i−1]）
        for i in range(1, lens1 + 1):
            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]
        # 3.初始化第一行 dp[0][j]，遍历第一行，遍历区间[1,len2+1)，表示 s2的前i位是否能构成s3的前i位：前 i-1位可以构成s3的前i−1位且s2的第i位（s2[i−1]）等于s3的第i位（s3[i-1]）
        for j in range(1, lens2 + 1):
            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]
        # 4.遍历顺序
        for i in range(1, lens1 + 1):
            for j in range(1, lens2 + 1):
                # 2.s1前i位和s2的前j位能否组成s3的前i+j位取决于两种情况：s1的前i个字符和s2的前j-1个字符能否构成s3的前i+j−1位，且s2的第j位（s2[j−1]）是否等于s3的第i+j位（s3[i+j−1]） 
                dp[i][j] = (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1]) or (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1])
        
        return dp[-1][-1]
```



#### ✅[最大正方形](https://leetcode-cn.com/problems/maximal-square/)

```python
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:

        m, n = len(matrix), len(matrix[0])
        maxside = 0
        dp = [[0 for _ in range(n)] for _ in range(m)]  # dp[i][j] 以 matrix[i][j] 为右下角的正方形的最大边长

        for i in range(m):
            for j in range(n):
                if matrix[i][j] == '1':
                    if i == 0 or j == 0:
                        dp[i][j] = 1
                    else:
                        dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][ j - 1]) + 1
                maxside = max(maxside, dp[i][j])

        return maxside ** 2
```

![image.png](./assets/8c4bf78cf6396c40291e40c25d34ef56bd524313c2aa863f3a20c1f004f32ab0-image.png)



# 背包问题



- 对于面试的话，其实掌握01背包，和完全背包，就够用了，最多可以再来一个多重背包；
- 而完全背包又是也是01背包稍作变化而来，即：**完全背包的物品数量是无限的**；
- **背包问题的理论基础重中之重是01背包，一定要理解透！**



![416.分割等和子集1](./assets/20210117171307407.png)



**dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷；**



------



## 01背包理论（二维数组）



Q：有`n`件物品和一个最多能背重量为`w `的背包。第`i`件物品的重量是`weight[i]`，得到的价值是`value[i]` 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大？

<img src="./assets/20210117175428387.jpg" alt="动态规划-背包问题" style="zoom:50%;" />

**暴力的解法：**每一件物品其实只有两个状态，取或者不取，所以可以使用**回溯法**搜索出所有的情况，那么时间复杂度就是`O(2^n)`，这里的n表示物品数量，是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化；



| （背包重量为4） | 重量 | 价值 |
| --------------- | ---- | ---- |
| 物品0           | 1    | 15   |
| 物品1           | 3    | 20   |
| 物品2           | 4    | 30   |



**1. 确定dp数组以及下标的含义：->**

- 使用二维数组，即**`dp[i][j] `表示从下标为`[0-i]`的物品里任意取，放进容量为`j`的背包，价值总和最大是多少**

<img src="./assets/20210110103003361.png" alt="动态规划-背包问题1"  />



**2. 确定递推公式：->**

- **不放物品`i`**：由`dp[i-1][j]`推出，即背包容量为`j`，里面不放物品`i`的最大价值，此时`dp[i][j]`就是`dp[i-1][j]`（其实就是当物品`i`的重量大于背包`j`的剩余重量时，物品`i`无法放进背包中，所以被背包内的价值依然和前面相同）；
- **放物品`i`**：由`dp[i-1][j-weight[i]]`推出，`dp[i-1][j-weight[i]] `为背包容量为`j - weight[i]`的时候不放物品`i`的最大价值，那么`dp[i-1][j-weight[i]]+value[i] `，就是背包放物品`i`得到的最大价值；
- 递归公式： `dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i])`；



**3. dp数组初始化：->**

- **关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱；**
- 首先从`dp[i][j]`的定义出发，如果背包容量`j`为0的话，即`dp[i][0]`，无论是选取哪些物品，背包价值总和一定为0；

<img src="./assets/2021011010304192.png" alt="动态规划-背包问题2"  />

```python
for i in range(len(weight)):
    dp[i][0] = 0
```



- 状态转移方程` dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i])`; 可以看出`i` 是由` i-1` 推导出来，那么`i`为0的时候就一定要初始化；
- `dp[0][j]`，即：`i`为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值：很明显当` j < weight[0]`的时候，`dp[0][j] `应该是 0，因为背包容量比编号0的物品重量还小；当`j >= weight[0]`时，`dp[0][j] `应该是`value[0]`，因为背包容量放足够放编号0物品；

<img src="./assets/20210110103109140.png" alt="动态规划-背包问题7"  />

```python
for j in range(bagsize + 1):
    if j < weight[0]:
        dp[0][j] = 0
    else:
        dp[0][j] = value[0]
```



**最终初始化dp数组：**

![动态规划-背包问题10](./assets/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%9810.jpg)



**4. 确定遍历顺序：->**

- 有两个遍历的维度：物品与背包重量，01背包先遍历物品，再遍历重量；



**5. 举例推导dp数组：->**

![动态规划-背包问题4](./assets/20210118163425129.jpg)



```python
class Solution:
    def back_pack_i_i(self, bagweight, weight, value):

        len_weight, len_bagweight = len(weight), bagweight
        dp = [[0 for _ in range(len_bagweight + 1)] for _ in range(len_weight)]

        for j in range(weight[0], len_bagweight + 1):
            dp[0][j] = value[0]

        for i in range(1, len_weight):
            for j in range(len_bagweight + 1):
                if j < weight[i]:
                    dp[i][j] = dp[i - 1][j]
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])

        return dp[-1][-1]
```



------

## 01背包理论（一维数组）



```
滚动数组: 就是把二维dp数组降为一维dp数组
```



- **`dp[i][j]`表示从下标为`[0-i]`的物品里任意取，放进容量为`j`的背包，价值总和最大是多少**；
- 对于背包问题其实状态都是可以压缩的，在使用二维数组的时候，递推公式：`dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i])`；
- 其实可以发现如果把`dp[i - 1]`那一层拷贝到`dp[i]`上，表达式完全可以是：`dp[i][j] = max(dp[i][j], dp[i][j-weight[i]] + value[i])`；
- **与其把`dp[i - 1]`这一层拷贝到`dp[i]`上，不如只用一个一维数组了**，只用`dp[j]`（一维数组，也可以理解是一个滚动数组）；
- 需要满足的条件是上一层可以重复利用，直接拷贝到当前层；



**1. 确定dp数组的定义：->**

- `dp[j]`表示：容量为`j`的背包，所背的物品价值可以最大为`dp[j]`；



**2.一维dp数组的递推公式：->**

- `dp[j]`可以通过`dp[j - weight[i]]`推导出来，`dp[j - weight[i]]`表示容量为`j - weight[i]`的背包所背的最大价值，`dp[j - weight[i]] + value[i] `表示 容量为`j - weight[i]`的背包 加上 物品`i`的价值（也就是容量为`j`的背包，放入物品`i`了之后的价值即：`dp[j]`）；
- 此时`dp[j]`有两个选择，一个是取自己`dp[j] `相当于 二维dp数组中的`dp[i-1][j]`，即不放物品`i`，一个是取`dp[j - weight[i]] + value[i]`，即放物品`i`，之后取max，毕竟是求最大价值；
- 可以看出相对于二维dp数组的写法，就是把`dp[i`][j]中`i`的维度去掉了；

```py
dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
```



**3. 一维dp数组如何初始化：->**

- **关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱**；
- `dp[j]`表示：容量为`j`的背包，所背的物品价值可以最大为`dp[j]`，那么`dp[0]`就应该是0，因为背包容量为0所背的物品的最大价值就是0；
- 那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少？看一下递归公式：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`，dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，**这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了**；



**4.一维dp数组遍历顺序：->**

- 二维dp遍历的时候，背包容量是从小到大，**而一维dp遍历的时候，背包是从大到小**；
- **倒序遍历是为了保证物品`i`只被放入一次！**但如果一旦正序遍历了，那么物品0就会被重复加入多次！
- 举个例子：物品0的重量`weight[0] = 1`，价值`value[0] = 15`：
  - 如果**正序遍历**，`dp[1] = max(0, dp[1 - weight[0]] + value[0]) = 15`，`dp[2] = max(0, dp[2 - weight[0]] + value[0]) = 30`，此时`dp[2]`就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历；

  - 为什么**倒序遍历**，就可以保证物品只放入一次呢？倒序就是先算`dp[2]`，`dp[2] = max(0, dp[2 - weight[0]] + value[0]) = 15 `（dp数组已经都初始化为0），`dp[1] = max(0, dp[1 - weight[0]] + value[0]) = 15`，所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了；

- 倒序遍历的原因是，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖；
- **为什么二维dp数组历的时候不用倒序呢？**因为对于二维dp，``dp[i][j]`都是通过上一层即`dp[i - 1][j]`计算而来，**本层的`dp[i][j]`并不会被覆盖！**
- **再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？**不可以！因为一维dp的写法，背包容量一定是要倒序遍历，如果遍历背包容量放在外层，那么每个`dp[j]`就只会放入一个物品，**即：背包里只放入了一个物品**；-> 因为做了dp压缩，如果是二维数组的话就可以交换遍历顺序



**5. 举例推导dp数组： ->**

![动态规划-背包问题9](./assets/20210110103614769.png)



```python
class Solution:
    def backpack2(self, weight, value, bagweight):
        dp = [0 for _ in range(bagweight + 1)]
        
        # 一维dp遍历的时候，背包是从大到小，倒叙遍历是为了保证物品i只被放入一次！
        for i in range(len(weight)):
            for j in range(bagweight, weight[i] - 1, -1):  # 注意这里取到weight[i]，背包小于这个值放不进去
                dp[j] = max(dp[j], dp[j - weight[i]] + value[i])

        return dp[-1]
```



------

## 背包递推公式



- **能否能装满背包（或者最多装多少）**：`dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])`
- **装满背包有几种方法**：`dp[j] += dp[j - nums[i]] `
- **背包装满最大价值**：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`
- **装满背包所有物品的最小个数**：`dp[j] = min( dp[j], dp[j - coins[i]] + 1)`

 

------

## 背包问题遍历顺序



- **01背包：**
  - **二维dp数组，外层遍历物品 + 内层遍历背包，外层遍历背包 + 内层遍历物品，都可以，从小到大遍历；**

  - **一维dp数组，外层遍历物品，内层遍历背包，物品从小到大遍历，背包是从大到小遍历；**

- **完全背包：**
  - **一维dp数组，外层遍历物品，内层遍历背包，物品从小到大遍历，背包是从小到大遍历；**




- 如果**求组合数**就是**外层for循环遍历物品，内层for遍历背包；**
- 如果**求排列数**就是**外层for遍历背包，内层for循环遍历物品；**

假设：`coins[0] = 1，coins[1] = 5`：

- 外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况：那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况，所以这种遍历顺序中dp[j]里计算的是组合数！

```c++
for (int i = 0; i < coins.size(); i++) { // 遍历物品
    for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量
        dp[j] += dp[j - coins[i]];
    }
}
```

- 如果把两个for交换顺序，背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况，此时dp[j]里算出来的就是排列数！

```c++
for (int j = 0; j <= amount; j++) { // 遍历背包容量
    for (int i = 0; i < coins.size(); i++) { // 遍历物品
        if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]];
    }
}
```



## 01 背包



### ✅[背包问题 II](https://www.lintcode.com/problem/backpack-ii/description)

**`dp(i, j) `为前 i 个物品，装入` j `背包的最大价值**

```python
class Solution:
    # 二维01背包
    def back_pack_i_i(self, bagweight, weight, value):

        len_weight, len_bagweight = len(weight), bagweight
        dp = [[0 for _ in range(len_bagweight + 1)] for _ in range(len_weight)]

        for j in range(weight[0], len_bagweight + 1):
            dp[0][j] = value[0]

        for i in range(1, len_weight):
            for j in range(len_bagweight + 1):
                if j < weight[i]:
                    dp[i][j] = dp[i - 1][j]
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])

        return dp[-1][-1]
    
    # 一维01背包
    def backpack2(self, weight, value, bagweight):
        dp = [0 for _ in range(bagweight + 1)]
        
        # 一维dp遍历的时候，背包是从大到小，倒叙遍历是为了保证物品i只被放入一次！
        for i in range(len(weight)):
            for j in range(bagweight, weight[i] - 1, -1):  # 注意这里取到weight[i]，背包小于这个值放不进去
                dp[j] = max(dp[j], dp[j - weight[i]] + value[i])

        return dp[-1]
```



### ✅[分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

**0-1背包：只要找到集合里能够出现 sum // 2 的子集总和，就算是可以分割成两个相同元素和子集了**

- 背包的体积为sum // 2；
- 背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为 元素的数值；
- 背包如果正好装满，说明找到了总和为 sum // 2 的子集；
- 背包中每一个元素是不可重复放入；

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:  
        # 本题相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]
        if sum(nums) % 2 == 1:  return False
        target = sum(nums) // 2
        # 1.dp[i]表示背包总容量为i，最大可以凑齐i的子集总和为dp[i]
        dp = [0 for _ in range(target + 1)]  # 3.dp初始化

        # 4.确定遍历顺序:如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒叙遍历
        for i in range(len(nums)):
            for j in range(target, nums[i] - 1, -1):
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])  # 2.递推公式
        
        return dp[-1] == target   # 如果dp[i] == i 说明，集合中的子集总和正好可以凑成总和i
```



### ✅[最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/)

**尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，**这样就化解成01背包问题了

```python
class Solution:
    def lastStoneWeightII(self, stones: List[int]) -> int:
      
        sumstones = sum(stones)
        target = sumstones // 2
        # 1.dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背dp[j]这么重的石头
        dp = [0 for _ in range(target + 1)]  # 3.dp数组初始化

        for i in range(len(stones)):  # 4.遍历顺序
            for j in range(target, stones[i] - 1, -1):
                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])  # 2.递推公式
        
        return abs((sumstones - dp[-1]) - dp[-1]) # (sumstones - dp[-1])表示另外一堆石头重量和
```



### ✅[目标和](https://leetcode-cn.com/problems/target-sum/)

**这次和之前遇到的背包问题不一样了，之前都是求容量为j的背包，最多能装多少；本题则是装满有几种方法，其实这就是一个组合问题了；**

- 分成加法和减法两个集合；
- `+(left) - (right) = target`
- `left + right = sum`
- `left = (sum + target) // 2`

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:

        sumNums = sum(nums)
        if sumNums < target: return 0
        if (sumNums + target) % 2 == 1: return 0
        bagSize = (sumNums + target) // 2
        if bagSize < 0:  return 0  # bagsize有可能有为负数
        
        # 1.dp[j] 表示：填满j这么大容积的包，有dp[i]种方法
        # 3.dp数组初始化,dp[0] = 1，装满容量为0的背包，有1种方法，就是装0件物品
        dp = [0 for _ in range(bagSize + 1)]
        dp[0] = 1
        # 4.确定遍历顺序:对于01背包问题一维dp的遍历，nums放在外循环，target在内循环，且内循环倒序
        for i in range(len(nums)):
            for j in range(bagSize, nums[i] - 1, -1):
                dp[j] += dp[j - nums[i]]  # 2.递推公式:不考虑nums[i]的情况下，填满容量为j - nums[i]的背包，有dp[j - nums[i]]中方法,那么只要搞到nums[i]的话，凑成dp[j]就有dp[j - nums[i]]种方法
        return dp[-1]
```



#### ✅[ 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

- **strs 数组里的元素就是物品,每个物品都是一个**；
- **而m 和 n相当于是一个背包，两个维度的背包**；
- **字符串的zeroNum和oneNum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）**;

```python
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:

        # 3.dp数组初始化
        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]  # 1.dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]
        #4.确定遍历顺序
        # st是物品
        for st in strs:
            num0, num1 = st.count("0"), st.count("1")

            for i in range(m, num0 - 1, -1):
                for j in range(n, num1 - 1, -1):
                    dp[i][j] = max(dp[i][j], dp[i - num0][j - num1] + 1)  # 2.dp[i][j] 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1,dp[i][j] 就可以是 dp[i - zeroNum][j - oneNum] + 1,字符串的zeroNum和oneNum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）
        
        return dp[-1][-1]
```



## 完全背包



- **完全背包和01背包问题唯一不同的地方就是，每种物品有无限件：**有N件物品和一个最多能背重量为W的背包，第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（即可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大；

- **代码中01背包和完全背包唯一不同就是体现在遍历顺序上**：完全背包的物品是可以添加多次的，所以遍历背包容量时从小到大去遍历；



回顾一下01背包的核心代码：

```c++
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

我们知道01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次；而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：

```c++
// 先遍历物品，再遍历背包
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j < bagWeight ; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```



#### ✅[零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

本题和纯完全背包不一样：**纯完全背包是能否凑成总金额，而本题是要求凑成总金额的组合数(组合不强调元素之间的顺序，排列强调元素之间的顺序)；求装满背包有几种方法，一般公式都是：dp[j] += dp[j - nums[i]]；**

```python
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        # 1.dp[j]：凑成总金额j的货币组合数为dp[j]
        dp = [0 for _ in range(amount + 1)]
        dp[0] = 1  # 3.dp数组初始化：dp[0] = 1,从dp[i]的含义上来讲就是，凑成总金额0的货币组合数为1
				# 遍历顺序：组合外层for循环遍历物品，内层for遍历背包
        for i in range(len(coins)):
            for j in range(coins[i], amount + 1):
                dp[j] += dp[j - coins[i]] # 2.递推公式:求装满背包有几种方法，一般公式都是：dp[j] += dp[j - nums[i]]
        
        return dp[-1]
```



#### ✅[组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

```python
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        # 1.dp[i]: 凑成目标正整数为i的排列个数为dp[i]
        dp = [0 for _ in range(target + 1)]
        dp[0] = 1  # 3.dp数组初始化:装满0的背包有1种方法
        # 4.遍历顺序：求排列数就是外层for遍历背包，内层for循环遍历物品，(1, 1, 2)和(1, 2, 1)属于两种方法
        for j in range(target + 1):
            for i in range(len(nums)):
                if j - nums[i] >= 0:
                    dp[j] += dp[j - nums[i]]  # 2.求装满背包有几种方法，递推公式一般都是dp[j] += dp[j - nums[i]]
        
        return dp[-1]
```



#### ✅[m阶爬楼梯](https://github.com/Inmessionant/leetcode-master/blob/master/problems/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.md)

**Q：一步一个台阶，两个台阶，三个台阶，.......，直到 m个台阶。问有多少种不同的方法可以爬到楼顶呢？**

- **等效于完全背包 - 排列问题：bagsize=n, 物品为1~m，每一阶可以重复使用，例如跳了1阶，还可以继续跳1阶，问跳到楼顶有几种方法其实就是问装满背包有几种方法；**
- **和 377. 组合总和 Ⅳ  基本就是一道题了，1、2 步 和 2、1 步都是上三个台阶，但是这两种方法不一样，所以这是排列问题，需将bagsize放在外循环，将nums放在内循环**

```python
class Solution:
    def climbStairs(self, n: int) -> int:
      # dp[i]：爬到有i个台阶的楼顶，有dp[i]种方法
        dp = [0 for _ in range(n + 1)]
        dp[0] = 1  # 3.dp数组初始化:上到楼顶为0，有1种方法

        # 4.遍历顺序：由于1、2 步 和 2、1 步都是上三个台阶，但是这两种方法不一样，所以这是排列问题，先遍历背包，后遍历物品，物品就是从1～m阶梯
        for j in range(n + 1):
            for i in range(1, m + 1):
                if j - i >= 0:
                    dp[j] += dp[j - i]  # 2.求装满背包有几种方法，递推公式一般都是dp[j] += dp[j - nums[i]]
        return dp[n]
```



#### ✅[零钱兑换](https://leetcode-cn.com/problems/coin-change/)

```Python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        # 1.dp[j]代表含义：填满容量为j的背包最少需要多少硬币
        # 3.dp初始化，判断最小需要多少硬币，初始化为“inf”，dp[0]=0表示装满0最少需要0个硬币
        dp = [float("inf") for _ in range(amount + 1)]
        dp[0] = 0

        # 4.遍历顺序：完全背包的物品是可以添加多次的，所以两重循环要从小到大去遍历
        for i in range(len(coins)):
            for j in range(coins[i], amount + 1):
                dp[j] = min(dp[j], dp[j - coins[i]] + 1) # 2.转移方程
        
        return dp[-1] if dp[-1] != float("inf") else -1

```



#### ✅[完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

**Q：完全平方数就是物品（可以无限件使用），凑个正整数n就是背包，问凑满这个背包最少有多少物品？**

```python
class Solution:
    def numSquares(self, n: int) -> int:
        
        nums = [i ** 2 for i in range(1, int(math.sqrt(n)) + 1)]
        # 1.dp[i]：和为i的完全平方数的最少数量为dp[i]
        dp  = [float("inf") for _ in range(n + 1)]
        # 3.dp数组初始化,p[0]表示 和为0的完全平方数的最小数量，那么dp[0]一定是0
        dp[0] = 0
        # 4.遍历顺序,我们知道这是完全背包，如果求组合数就是外层for循环遍历物品，内层for遍历背包。如果求排列数就是外层for遍历背包，内层for循环遍历物品。在动态规划：322. 零钱兑换中我们就深入探讨了这个问题，本题也是一样的，是求最小数！所以本题外层for遍历背包，里层for遍历物品，还是外层for遍历物品，内层for遍历背包，都是可以的！
        for i in range(len(nums)):
            for j in range(nums[i], n + 1):
                dp[j] = min(dp[j], dp[j - nums[i]] + 1)# 2.dp[j] 可以由dp[j - i * i]推出， dp[j - i * i] + 1 便可以凑成dp[j];此时我们要选择最小的dp[j]，所以递推公式：dp[j] = min(dp[j - i * i] + 1, dp[j]);
        
        return dp[-1]
```



#### ✅[单词拆分](https://leetcode-cn.com/problems/word-break/)


```Python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
				# 1.dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词
        dp = [False for _ in range(len(s) + 1)]
        dp[0] = True  # 3.dp数组初始化：长度为0的字符串可以拆分为在字典中出现的单词

        for i in range(1, len(s) + 1):
            for k in range(i):
              # 2.递推公式：如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true（j < i ）
                if dp[k] and s[k:i] in wordDict:
                    dp[i] = True
        
        return dp[-1]
```



# 打家劫舍



#### ✅[打家劫舍](https://leetcode-cn.com/problems/house-robber/) 

```python
class Solution:
    def rob(self, nums: List[int]) -> int:

        n = len(nums)
        if n == 1: return nums[0]
        # 1.dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]
        dp = [0 for _ in range(n)]
        # 3.dp数组初始化,从递推公式dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);可以看出，递推公式的基础就是dp[0] 和 dp[1],从dp[i]的定义上来讲，dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值即：dp[1] = max(nums[0], nums[1]);
        dp[0], dp[1] = nums[0], max(nums[0], nums[1])
        #4.遍历顺序,dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！
        for i in range(2, n):
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]) #2.递推公式,决定dp[i]的因素就是第i房间偷还是不偷,如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱,如果不偷第i房间，那么dp[i] = dp[i - 1]，即考虑i-1房，（注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点）
        
        return dp[-1]
```

细心的我们发现： 难道在前 n 间的最高金额 dp[n]情况下，第 n间一定被偷了吗？假设没有被偷，那n+1 间的最大值应该也可能是 dp[n+1] = dp[n] + num吧？其实这种假设的情况可以被省略，这是因为：

- 假设第 n 间没有被偷，那么此时 dp[n] = dp[n-1]，此时 dp[n+1] = dp[n] + num = dp[n-1] + num ，即两种情况可以 合并为一种情况 考虑；
- 假设第 n 间被偷，那么此时 dp[n+1] = dp[n] + num不可取 ，因为偷了第 n间就不能偷第 n+1 间；




#### ✅[打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/) 

```python
class Solution:
    def rob(self, nums: List[int]) -> int:

        def robaction(array):
            n = len(array)
            dp = [0 for _ in range(n)]
            dp[0], dp[1] = array[0], max(array[0], array[1])
            
            for i in range(2, n):
                dp[i] = max(dp[i - 2] + array[i], dp[i - 1]) 
            return dp[-1]

        n = len(nums)
        if n == 1: return nums[0]
        if n == 2: return max(nums)
        left = robaction(nums[0: n - 1])
        right = robaction(nums[1: n])
        return max(left, right)
```

**环状排列**意味着第一个房子和最后一个房子中**只能选择一个偷窃**，因此可以把此**环状排列房间**问题约化为两个**单排排列房间**子问题：

- 在不偷窃第一个房子的情况下（即 nums[1:]），最大金额是 p_1 ；
- 在不偷窃最后一个房子的情况下（即 nums[:n-1]），最大金额是 p_2；
- **综合偷窃最大金额：** 为以上两种情况的较大值，即 max(p1,p2)；



#### ✅[打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

```python
class Solution:
    #长度为2的数组，0：不偷，1：偷
    def robtree(self, node):
        if not node:
            return [0, 0]
        left = self.robtree(node.left)
        right = self.robtree(node.right)

        res2 = left[0] + right[0] + node.val # 偷node
        res1 = max(left) + max(right) # 不偷node

        return [res1, res2]

    def rob(self, root: TreeNode) -> int:
        res = self.robtree(root)
        return max(res)
```



# 股票问题



#### ✅[买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # 1.dp[i][0] 表示第i天持有股票所得最多现金, dp[i][1] 表示第i天不持有股票所得最多现金
        # 3.dp数组初始化
        dp = [[0 for _ in range(2)] for _ in range(len(prices))]
        dp[0][0], dp[0][1] = -prices[0], 0
        # 4.遍历顺序
        for i in range(1, len(prices)):
            # 2.递推公式
            dp[i][0] = max(dp[i - 1][0], -prices[i])  # 注意这里，只能买一次
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])

        return dp[-1][1]
```



#### ✅[买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # 1.dp[i][0] 表示第i天持有股票所得现金,dp[i][1] 表示第i天不持有股票所得最多现金
        # 3.dp数组初始化
        dp = [[0 for _ in range(2)] for _ in range(len(prices))]
        dp[0][0], dp[0][1] = -prices[0], 0 
        # 4.遍历顺序
        for i in range(1, len(prices)):
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]) # 2.递推公式，注意这里是和121. 买卖股票的最佳时机唯一不同的地方，可以买卖多次了
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i], )  # 你也可以先购买，然后在 同一天出售，其实就是前一天不持有
        
        return dp[-1][1]
```



#### ✅[买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

```python
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        m = len(prices)
        if m == 0: return 0
        dp = [[0 for _ in range(2)] for _ in range(m)]
        dp[0][0] = -prices[0]

        for i in range(1, m):
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee)
        
        return dp[-1][-1]
```



#### ✅[买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # 1.dp数组以及下标的含义:一天一共就有五个状态， 0. 没有操作 1.第一次买入 2.第一次卖出 3.第二次买入 4.第二次卖出 dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金
        # 3.dp数组初始化
        dp = [[0 for _ in range(5)] for _ in range(len(prices))]
        dp[0][1], dp[0][3] = -prices[0], -prices[0]
        # 4.遍历顺序
        for i in range(1, len(prices)):
            # 2.递推公式
            dp[i][0] = dp[i - 1][0]
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]) # dp[i][1]，表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i])
            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i])
            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i])
        
        return max(dp[-1])
```



#### ✅[买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        m, n = len(prices), 2 * k + 1
        if m == 0: return 0
        # 确定dp数组以及下标的含义：使用二维数组 dp[i][j] ：第i天的状态为j，所剩下的最大现金是dp[i][j]，j的状态表示为：0 表示不操作 1 第一次买入 2 第一次卖出 3 第二次买入 4 第二次卖出 ..... 除了0以外，偶数就是卖出，奇数就是买入状态，题目要求是至多有K笔交易，那么j的范围就定义为 2 * k + 1 就可以了
        dp = [[0 for _ in range(n)] for _ in range(m)]
        # 3.dp数组初始化：第0天没有操作，这个最容易想到，就是0;第1天做第一次买入的操作，dp[0][1] = -prices[0];第2天做第一次卖出的操作，dp[0][2] = 0;所以同理可以推出dp[0][j]当j为奇数的时候都初始化为 -prices[0]（一天买卖多次）
        for j in range(1, 2 * k + 1, 2):
            dp[0][j] = -prices[0]
        # 4.遍历顺序
        for i in range(1, m):
            for j in range(0, 2 * k - 1, 2):
                # 2.递推公式
                dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]) 
                dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i])
        
        return max(dp[-1])
```



#### ✅[最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

**因为出现冷冻期之后，状态其实是比较复杂度**。 具体可以区分出如下四个状态：

- 0 状态一：买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）
- 卖出股票状态，这里就有两种卖出股票状态:
  - 1 状态二：昨天冷冻期；今天没操作，保持卖出股票状态；
  - 2 状态三：今天卖出了股票；
- 3 状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！

```Python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:

        if not prices: return 0
        m = len(prices)
        dp = [[0 for _ in range(4)] for _ in range(m)]
        dp[0][0] = -prices[0]

        for i in range(1, m):
            # 前一天就是持有股票状态（状态一）,前一天是保持卖出股票状态（状态二）,前一天是冷冻期（状态四）
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i], dp[i - 1][3] - prices[i])
            # 前一天就是状态二,前一天是冷冻期（状态四）
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][3])
            # 昨天一定是买入股票状态（状态一），今天卖出
            dp[i][2] = dp[i - 1][0] + prices[i]
            # 昨天卖出了股票（状态三）
            dp[i][3] = dp[i - 1][2]
        
        return max(dp[-1])
```



# 子序列问题



## 子序列



#### ✅[最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

不是最长连续递增子序列，找到其中**最长严格递增子序列**的长度

```Python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        # 1.dp[i]表示i之前包括i的最长上升子序列  3.dp初始化
        # 3.dp数组初始化,以下标i为结尾的数组的连续递增的子序列长度最少也应该是1
        dp = [1 for _ in range(len(nums))]
        res = 1

        for i in range(len(nums)):  #4.确定遍历顺序
            for k in range(i):
                if nums[i] > nums[k]:
                    dp[i] = max(dp[i], dp[k] + 1)  # 2.递推公式，位置i的最长升序子序列等于k从0到i-1各个位置的最长升序子序列 + 1 的最大值
            res = max(res, dp[i])  # 原因是num[i]不一定比num[k]大，所以要用res记录
        
        return res
```



#### ✅[最长连续递增序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)

- 本题相对于[动态规划：300.最长递增子序列](https://mp.weixin.qq.com/s/f8nLO3JGfgriXep_gJQpqQ)最大的区别在于递增子序列是“连续”的；
- 概括来说：**不连续递增子序列的跟前0-i 个状态有关，连续递增的子序列只跟前一个状态有关**；

```python
class Solution:
    def findLengthOfLCIS(self, nums: List[int]) -> int:
        # 1.dp[i]：以下标i为结尾的数组的连续递增的子序列长度为dp[i],注意这里的定义，一定是以下标i为结尾，并不是说一定以下标0为起始位置
        # 3.dp数组初始化,以下标i为结尾的数组的连续递增的子序列长度最少也应该是1
        dp = [1 for _ in range(len(nums))]  
        res = 1
        # 4.遍历顺序
        for i in range(1, len(nums)):
            if nums[i] > nums[i - 1]:
                dp[i] = dp[i - 1] + 1 # 2.递推公式,因为本题要求连续递增子序列，所以就必要比较nums[i + 1]与nums[i]，而不用去比较nums[k]与nums[i] （k是在0到i之间遍历）
            res = max(res, dp[i])
        
        return res
```



#### ✅[俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes/)

```python
class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:

        res = 1
        dp = [1 for _ in range(len(envelopes))]
        envelopes.sort(key=lambda x: (x[0], -x[1]))

        for i in range(len(envelopes)):
            for k in range(i):
                if envelopes[i][1] > envelopes[k][1]:
                    dp[i] = max(dp[i], dp[k] + 1)
            res = max(res, dp[i])
        
        return res
```



#### [最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)


```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:

        if not nums: return 0
        
        n = len(nums)
        nums = sorted(nums)
        dp = [1 for _ in range(n)]
        res = 1

        for i in range(n - 2, -1, -1):
            if nums[i] + 1 ==  nums[i + 1]:
                dp[i] += dp[i + 1]
            elif nums[i] == nums[i + 1]:
                dp[i] = dp[i + 1]
            
            res = max(res, dp[i])
            
        return res
```



#### [最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)

- 注意题目中说的**子数组，其实就是连续子序列**


```python
class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:

        m, n = len(nums1), len(nums2)
        # 1.dp[i][j] ：以下标i - 1为结尾的num1，和以下标j - 1为结尾的num2，最长重复子数组长度为dp[i][j]
        # 3.dp数组初始化:
        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]
        
        res = 0
        # 4.遍历顺序:遍历i 和 j 要从1开始,同时题目要求长度最长的子数组的长度。所以在遍历的时候顺便把dp[i][j]的最大值记录下来
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if nums1[i - 1] == nums2[j - 1]:  # 2.递推公式
                    dp[i][j] = dp[i - 1][j - 1] + 1
                res = max(res, dp[i][j])
        
        return res
```

空间优化，**滚动数组**

我们可以看出`dp[i][j]`都是由`dp[i - 1][j - 1]`推出。那么压缩为一维数组，也就是`dp[j]`都是由`dp[j - 1]`推出；

也就是相当于可以把上一层`dp[i - 1][j]`拷贝到下一层`dp[i][j]`来继续用；

**此时遍历B数组的时候，就要从后向前遍历，这样避免重复覆盖**

```python
class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        m, n = len(nums1), len(nums2)
        dp = [0 for _ in range(n + 1)]
        res = 0

        for i in range(1, m + 1):
            for j in range(n, 0, -1):
                if nums1[i - 1] == nums2[j - 1]:
                    dp[j] = dp[j -1] + 1
                else: 
                    dp[j] = 0
                res = max(res, dp[j])

        return res
```



#### [最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

- 本题和[动态规划：718. 最长重复子数组](https://mp.weixin.qq.com/s/U5WaWqBwdoxzQDotOdWqZg)区别在于这里**不要求是连续的了**，但要**有相对顺序**，即："ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列；
- 之所以` dp[i][j] `的定义不是` text1[0:i] `和` text2[0:j] `，是为了方便当` i = 0 `或者` j = 0 `的时候，`dp[i][j]`表示的为空字符串和另外一个字符串的匹配，这样 `dp[i][j] `可以初始化为 0；
- 当` text1[i - 1] == text2[j - 1] `时，说明两个子字符串的最后一位相等，所以最长公共子序列又增加了 1，所以 `dp[i][j] = dp[i - 1][j - 1] + 1`；举个例子，比如对于 ac 和 bc 而言，他们的最长公共子序列的长度等于 a 和 b 的最长公共子序列长度 0 + 1 = 1；

- 当` text1[i - 1] != text2[j - 1] `时，说明两个子字符串的最后一位不相等，那么此时的状态` dp[i][j] `应该是` dp[i - 1][j] `和` dp[i][j - 1] `的最大值。举个例子，比如对于 ace 和 bc 而言，他们的最长公共子序列的长度等于 ① ace 和 b 的最长公共子序列长度0 与 ② ac 和 bc 的最长公共子序列长度1 的最大值，即 1；

```Python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        m, n = len(text1), len(text2)
        # 1.dp[i][j] ：以下标i - 1为结尾的text1，和以下标j - 1为结尾的text2，最长重复子数组长度为dp[i][j]
        # 3.dp数组初始化：当 i = 0 时，dp[0][j] 表示的是 text1 中取空字符串 跟 text2 的最长公共子序列，结果肯定为 0；当 j = 0 时，dp[i][0] 表示的是 text2 中取空字符串 跟 text1 的最长公共子序列，结果肯定为 0.
        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]
		# 4.确定遍历顺序(从1开始，表示以下标0为结尾的text1和text2)
        for i in range(1, m + 1):
            for j in range(1, n + 1): 
                if text1[i - 1] == text2[j - 1]: # 2.递推公式
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        
        return dp[-1][-1]
```



#### [不相交的线](https://leetcode-cn.com/problems/uncrossed-lines/)

直线不能相交，这就是说明在字符串A中 找到一个与字符串B相同的子序列，且这个子序列不能改变相对顺序，只要相对顺序不改变，链接相同数字的直线就不会相交;

拿示例一A = [1,4,2], B = [1,2,4]为例，其实也就是说A和B的最长公共子序列是[1,4]，长度为2。 这个公共子序列指的是相对顺序不变（即数字4在字符串A中数字1的后面，那么数字4也应该在字符串B数字1的后面）

这么分析完之后，大家可以发现：**本题说是求绘制的最大连线数，其实就是求两个字符串的最长公共子序列的长度！**

```python
class Solution:
    def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
        m, n = len(nums1), len(nums2)
        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if nums1[i - 1] == nums2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        
        return dp[-1][-1]
```



#### [最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

- 子序列是连续的

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        # 1.dp[i]：包括下标i之前的最大连续子序列和为dp[i]
        dp = [0 for _ in range(len(nums))]
        # 3.dp数组初始化
        dp[0], res = nums[0], nums[0]
        # 4.遍历顺序,递推公式中dp[i]依赖于dp[i - 1]的状态，需要从前向后遍历
        for i in range(1, len(nums)):
            dp[i] = max(nums[i], dp[i - 1] + nums[i]) # 2.递推公式,dp[i]只有两个方向可以推出来：dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和nums[i]，即：从头开始计算当前连续子序列和一定是取最大的，所以dp[i] = max(dp[i - 1] + nums[i], nums[i]);
            res = max(res, dp[i])
        
        return res
```



#### [乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:

        if not nums: return 0
        res, premin, premax = nums[0], nums[0], nums[0]

        for i in range(1, len(nums)):
            curmax = max(nums[i], premax * nums[i], premin * nums[i])
            curmin = min(nums[i], premax * nums[i], premin * nums[i])
            res = max(res, curmax)
            premax, premin = curmax, curmin
        
        return res
```



#### [删除一次得到子数组最大和](https://leetcode-cn.com/problems/maximum-subarray-sum-with-one-deletion/)

```python
class Solution:
    def maximumSum(self, arr: List[int]) -> int:
        n = len(arr)
        #1.dp[i][0]表示不删除元素的情况下最大子数组和（以arr[i]结尾）,dp[i][1]代表删除元素的情况下的最大子数组和（以arr[i]结尾）
        dp = [[0 for _ in range(2)] for _ in range(n)]
        # 3.初始化：d[0][0]表示不删除，d[0][0]=arr[0],dp[0][1]表示删除arr[0],因为arr有负数，二后面求max，所以dp[0][1]=float("-inf")
        res = arr[0]
        dp[0][0], dp[0][1] = arr[0], float("-inf")


        for i in range(1, n):
            dp[i][0] = max(dp[i - 1][0] + arr[i], arr[i]) # 2.要么是当前元素累加之前的和，要么是重新从当前元素开始
            dp[i][1] = max(dp[i - 1][1] + arr[i], dp[i - 1][0]) # 要么是加上当前元素，也就是维持之前删除某个元素的情形，即dp[i-1][1]+arr[i],要么是删除当前这个元素，那么区间[0, i-1]就是不删除元素的情况，即dp[i-1][0]
            res = max(res, dp[i][0], dp[i][1])
        
        return res
```



## 编辑距离



#### [判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

```python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:

        lens, lent = len(s), len(t)
        if lens > lent: return False
        # 1.dp[i][j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i][j]
        # 3.dp数组初始化
        dp = [[0 for _ in range(lent + 1)] for _ in range(lens + 1)]
         # 4.遍历顺序
        for i in range(1, lens + 1):
            for j in range(1, lent + 1):
                # 2.递推公式：if (s[i - 1] == t[j - 1])，那么dp[i][j] = dp[i - 1][j - 1] + 1;，因为找到了一个相同的字符，相同子序列长度自然要在dp[i-1][j-1]的基础上加1；if (s[i - 1] != t[j - 1])，此时相当于t要删除元素，t如果把当前元素t[j - 1]删除，那么dp[i][j] 的数值就是 看s[i - 1]与 t[j - 2]的比较结果了，即：dp[i][j] = dp[i][j - 1];
                if s[i - 1] == t[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = dp[i][j - 1]
        
        return True if dp[-1][-1] == lens else False
```



#### [不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/)

```python
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        m, n = len(s) + 1, len(t) + 1
        # 1.dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]
        # 3.dp数组初始化,dp[i][0] 表示：以i-1为结尾的s可以随便删除元素，出现空字符串的个数为1,dp[0][j]，dp[0][j]：空字符串s可以随便删除元素，出现以j-1为结尾的字符串t的个数为0
        dp = [[0 for _ in range(n)] for _ in range(m)]
        for i in range(m):
            dp[i][0] = 1
        # 4.遍历顺序
        for i in range(1, m):
            for j in range(1, n):
                # 2.递推公式
                if s[i - 1] == t[j - 1]:  # 用s[i-1]和t[j-1]来匹配，那么个数为dp[i-1][j-1],不用s[i-1]来匹配，用s[i-2]和t[j-1]匹配，个数为dp[i - 1][j]
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]  
                else:
                    dp[i][j] = dp[i - 1][j] # 当s[i-1] 与 t[j-1]不相等时，不用s[i - 1]来匹配
        
        return dp[-1][-1]
```



#### [两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/) 

本题和[不同的子序列](https://mp.weixin.qq.com/s/1SULY2XVSROtk_hsoVLu8A)相比，其实就是两个字符串可以都可以删除了，情况虽说复杂一些，但整体思路是不变的

删除哪个，哪个就-1，如删除word1，`dp[i - 1][j] + 1`， 删除word2，`dp[i][j - 1] + 1`

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:

        m, n = len(word1), len(word2)
        # 1.dp[i][j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数
        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]
        # dp数组初始化，dp[i][0]：word2为空字符串，以i-1为结尾的字符串word2要删除多少个元素，才能和word1相同呢，很明显dp[i][0] = i，dp[0][j]的话同理
        for i in range(m + 1):
            dp[i][0] = i
        
        for j in range(n + 1):
            dp[0][j] = j
        # 4.遍历顺序，从递推公式 dp[i][j] = min(dp[i - 1][j - 1] + 2, min(dp[i - 1][j], dp[i][j - 1]) + 1); 和dp[i][j] = dp[i - 1][j - 1]可以看出dp[i][j]都是根据左上方、正上方、正左方推出来的
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                # 2.递推公式
                if word1[i - 1] == word2[j - 1]: # 当word1[i - 1] 与 word2[j - 1]相同的时候，dp[i][j] = dp[i - 1][j - 1]
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                # 当word1[i - 1] 与 word2[j - 1]不相同的时候，有2种情况：情况一：删word1[i - 1]，最少操作次数为dp[i - 1][j] + 1，情况二：删word2[j - 1]，最少操作次数为dp[i][j - 1] + 1
                    dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1)
        
        return dp[-1][-1]
```



#### [编辑距离](https://leetcode-cn.com/problems/edit-distance/)

- `if (word1[i - 1] == word2[j - 1])`：

  那么说明不用任何编辑，`dp[i][j]` 就应该是 `dp[i - 1][j - 1]`，即`dp[i][j] = dp[i - 1][j - 1]`,`word1[i - 1]` 与 `word2[j - 1]`相等了，那么就不用编辑了，以下标i-2为结尾的字符串word1和以下标j-2为结尾的字符串`word2`的最近编辑距离`dp[i - 1][j - 1]`就是 `dp[i][j]`了

- `if (word1[i - 1] != word2[j - 1])`：

  此时就需要编辑了，对“`dp[i-1][j-1] `表示替换操作，`dp[i-1][j] `表示删除操作，`dp[i][j-1] `表示插入操作”的补充理解：以 word1 为 "horse"，word2 为 "ros"，且` dp[5][3] `为例，即要将 word1的前 5 个字符转换为 word2的前 3 个字符，也就是将 horse 转换为 ros，因此有：

  - ` dp[i-1][j-1]`，即先将 word1 的前 4 个字符 hors 转换为 word2 的前 2 个字符 ro，然后将第五个字符 word1[4]（因为下标基数以 0 开始） 由 e 替换为 s（即替换为 word2 的第三个字符，word2[2]）
  - `dp[i][j-1]`，即先将 word1 的前 5 个字符 horse 转换为 word2 的前 2 个字符 ro，然后在末尾补充一个 s，即插入操作
  - ` dp[i-1][j]`，即先将 word1 的前 4 个字符 hors 转换为 word2 的前 3 个字符 ros，然后删除 word1 的第 5 个字符

```Python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:

        m, n = len(word1), len(word2)
        # 1.dp[i][j] 表示以下标i-1为结尾的字符串word1转换成以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]
        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]
        # 初始化
        # dp[i][0] ：以下标i-1为结尾的字符串word1转换成空字符串word2，最近编辑距离为i,对word1里的元素全部做删除操作
        for i in range(m + 1):
            dp[i][0] = i
        # 同理dp[0][j] = j
        for j in range(n + 1):
            dp[0][j] = j
        # 遍历顺序
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                # 2.递推公式
                if word1[i - 1] == word2[j - 1]: 
                # if (word1[i - 1] == word2[j - 1]) 那么说明不用任何编辑，dp[i][j] 就应该是 dp[i - 1][j - 1]
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                #if (word1[i - 1] != word2[j - 1]),`dp[i-1][j-1] + 1 `表示替换操作，`dp[i-1][j] + 1`表示删除操作，`dp[i][j-1] + 1`表示插入操作
                    dp[i][j] = min(dp[i][j - 1] + 1, dp[i - 1][j] + 1, dp[i - 1][j - 1] + 1)
        
        return dp[-1][-1]
```



#### [通配符匹配](https://leetcode-cn.com/problems/wildcard-matching/)

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:

        m, n = len(s), len(p)
        # 1. dp[i][j] 表示字符串 s 的前 i 个字符和模式 p 的前 j 个字符是否能匹配
        dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]
        # 3.dp[0][0]=True，即当字符串 s 和模式 p 均为空时，匹配成功；dp[i][0]=False，即空模式无法匹配非空字符串；p[0][j] 需要分情况讨论：因为星号才能匹配空字符串，所以只有当模式 p 的前 j 个字符均为星号时，dp[0][j] 才为真;
        dp[0][0] = True

        for j in range(1, n + 1):
            if p[j - 1] == '*':
                dp[0][j] = True
            else:
                break
        # 4.遍历顺序
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                # 2.如果 p_j是小写字母，那么 s_i必须也为相同的小写字母;如果 p_j是问号，那么对 s_i没有任何要求;
                if p[j - 1] == s[i - 1] or p[j - 1] == '?':
                    dp[i][j] = dp[i - 1][j - 1]
                # 如果 p_j 是星号，那么同样对 s_i 没有任何要求，但是星号可以匹配零或任意多个小写字母，因此状态转移方程分为两种情况，即使用或不使用这个星号： 
                elif p[j - 1] == '*':
                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]

        return dp[-1][-1]
```



#### [正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:

        m, n = len(s), len(p)
        dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]
        dp[0][0] = True

        for j in range(2, n + 1, 2):  # 首行 s 为空字符串，因此当 p 的偶数位为 * 时才能够匹配（即让 p 的奇数位出现 0 次，保持 p 是空字符串）。因此，循环遍历字符串 p ，步长为 2（即只看偶数位）:"" 和p的匹配关系初始化，a*a*a*a*a*这种能够匹配空串，其他的是都是false。 奇数位不管什么字符都是false，偶数位为* 时则: dp[0][i] = dp[0][i - 2]
            dp[0][j] = p[j - 1] == '*' and dp[0][j - 2]
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if s[i - 1] == p[j - 1] or p[j - 1] == '.': # 遇到的是字符或者.
                    dp[i][j] = dp[i - 1][j - 1]
                elif p[j - 1] == '*': # 遇到*
                    if s[i - 1] == p[j - 2] or p[j - 2] == '.': #p[j - 2]位置是.或者和和s[i - 1]位置相等
                        # dp[i][j-1] 只使用单个字符匹配(不使用*),dp[i][j-2] 代表匹配 0次,dp[i-1][j] 代表使用多个字符匹配
                        dp[i][j] = dp[i][j - 2] or dp[i][j - 1] or dp[i - 1][j]
                    else: 
                        dp[i][j] = dp[i][j - 2]
                        
        return dp[-1][-1]
```

https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/jian-zhi-offer-19-zheng-ze-biao-da-shi-pi-pei-dong/



#### 构造回文数的最小代价

```python
def func(str1, cost):

    n = len(str1)
    arr = [0 for _ in range(5)]
    for i in range(len(cost)):
        arr[i + 1] = min(cost[i])

    dp = [[0 for _ in range(n)] for _ in range(n)]

    for i in range(n - 1, -1, -1):
        for j in range(i + 1, n):
            if str1[i] == str1[j]:
                dp[i][j] = dp[i + 1][j - 1]
            else:
                dp[i][j] = min(dp[i][j - 1] + arr[int(str1[j])], dp[i + 1][j] + arr[int(str1[i])])
                
    return dp[0][-1]


while True:
    try:
        line = input()
        cost = []
        for _ in range(4):
            cost.append(list(map(int, input().strip().split())))
        print(func(line, cost))
    except EOFError:
        break

        
12322
100 120
200 350
360 200
220 320
```

https://blog.csdn.net/ldm_666/article/details/118500810



## 回文



#### [回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

```python
class Solution:
    def countSubstrings(self, s: str) -> int:
        # 1.布尔类型的dp[i][j]：表示区间范围[i,j]的子串是否是回文子串，如果是dp[i][j]为true，否则为false
        # 3.dp数组初始化
        dp = [[False for _ in range(len(s))] for _ in range(len(s))]
        res = 0

        # 4.遍历顺序:从递推公式中可以看出，情况三是根据dp[i + 1][j - 1]是否为true，在对dp[i][j]进行赋值true的,dp[i + 1][j - 1] 在 dp[i][j]的左下角，所以一定要从下到上，从左到右遍历，这样保证dp[i + 1][j - 1]都是经过计算的
        for i in range(len(s) - 1, -1, -1):
            for j in range(i, len(s)):
                # 2.递推公式,当s[i]与s[j]不相等，dp[i][j]一定是false,当s[i]与s[j]相等时，有如下三种情况:情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串,情况二：下标i 与 j相差为1，例如aa，也是文子串,情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true
                if s[i] == s[j]:
                    if j - i <= 1:
                        res += 1
                        dp[i][j] = True
                    elif dp[i + 1][j - 1]:
                        res += 1
                        dp[i][j] = True
        
        return res
```



#### [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        dp = [[False for _ in range(n)] for _ in range(n)]
        len_res, res = 0, ""

        for i in range(n - 1, -1 ,-1):
            for j in range(i, n):
                if s[i] == s[j]:
                    if j - i <= 1:
                        dp[i][j] = True
                    elif dp[i + 1][j - 1]:
                        dp[i][j] = True
                
                if dp[i][j] and j - i + 1 > len_res:
                    len_res = j - i + 1
                    res = s[i: j + 1]
        
        return res
```



#### [最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

**回文子串是要连续的，回文子序列可不是连续的！**

```python
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        # 1.dp[i][j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i][j]
        # 3.dp数组初始化,首先要考虑当i 和j 相同的情况，从递推公式：dp[i][j] = dp[i + 1][j - 1] + 2; 可以看出 递推公式是计算不到 i 和j相同时候的情况。所以需要手动初始化一下，当i与j相同，那么dp[i][j]一定是等于1的，即：一个字符的回文子序列长度就是1,其他情况dp[i][j]初始为0就行，这样递推公式：dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); 中dp[i][j]才不会被初始值覆盖。
        dp = [[0 for _ in range(len(s))] for _ in range(len(s))]

        for i in range(len(s)):
            dp[i][i] = 1

        # 4.遍历顺序,p[i][j] = dp[i + 1][j - 1] + 2 和 dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) 可以看出，dp[i][j]是依赖于dp[i + 1][j - 1] 和 dp[i + 1][j]，所以遍历i的时候一定要从下到上，从左到右遍历
        for i in range(len(s) - 1, -1, -1):
            for j in range(i + 1, len(s)):
                # 2.递推公式,如果s[i]与s[j]相同，那么dp[i][j] = dp[i + 1][j - 1] + 2,如果s[i]与s[j]不相同，说明s[i]和s[j]的同时加入并不能增加[i,j]区间回文子串的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列
                if s[i] == s[j]:
                    dp[i][j] = dp[i + 1][j - 1] + 2
                else:
                    dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])
        
        return dp[0][-1]
```



#### [字符串成为回文串最少插入次数](https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/)

```python
class Solution:
    def minInsertions(self, s: str) -> int:
        ################ 思路:正面动态规划 dp
        n = len(s)
        ######## dp[L][R] [L, …… R]所能构成的最长回文子序列的长度
        dp = [[0 for _ in range(n)] for _ in range(n)]
        
        for L in range(n - 1, -1, -1):  #L依赖于L+1
            for R in range(L + 1, n):   #R依赖于R-1
                if s[L] == s[R]:
                    dp[L][R] = dp[L+1][R-1]
                else:
                    dp[L][R] = min(dp[L+1][R] + 1, dp[L][R-1] + 1)
        
        return dp[0][n-1]
```

