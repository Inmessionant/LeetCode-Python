

### 基础

- 回溯是递归的副产品，只要有递归就会有回溯；


- 回溯（backtrack）常用于遍历列表所有子集，是深度搜索一种，一般用于全排列，穷尽所有可能，遍历的过程实际上是一个决策树的遍历过程。
- 回溯法并不是什么高效的算法，时间复杂度一般 O(N!)，它不像动态规划存在重叠子问题可以优化，**因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案**，复杂度一般都很高；



**回溯解决的问题：**

- 组合问题：N个数里面按一定规则找出k个数的集合；
- 切割问题：一个字符串按一定规则有几种切割方式；
- 子集问题：一个N个数的集合里有多少符合条件的子集；
- 排列问题：N个数按一定规则全排列，有几种排列方式；
- 棋盘问题：N皇后，解数独等；

```
组合是不强调元素顺序的，排列是强调元素顺序；
例如：{1, 2} 和 {2, 1} 在组合上，就是一个集合，因为不强调顺序，而要是排列的话，{1, 2} 和 {2, 1} 就是两个集合了
```



**如何理解回溯：**

**回溯法解决的问题都可以抽象为树形结构（n叉树）**

- 因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度，都构成的树的深度**，递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）；
- 如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，**「那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！」**；



![回溯算法理论基础](https://camo.githubusercontent.com/f65ca647f31913496481cd1aff144040bd7ee4f6bc30accd370bc78b4b265d13/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303133303137333633313137342e706e67)



**模板：**

回溯三部曲：回溯函数返回值及参数、回溯函数终止条件、回溯搜索的遍历过程；

```python
def backtrack(选择列表,路径):
    if 满足结束条件:
        result.append(路径)
        return
    for 选择 in 选择列表:  # for循环可以理解是横向遍历
        做选择
        backtrack(选择列表,路径)  # backtrack就是纵向遍历，递归
        撤销选择
        
result = []
```

- 核心就是从选择列表里做一个选择，然后一直递归往下搜索答案，如果遇到路径不通，就返回来撤销这次选择；
- 针对有重复的解，我们在最开始要对nums排序，之后再res.append()时候只需判断path是否在res内即可；



### 组合



#### ✅[组合](https://leetcode-cn.com/problems/combinations/)

```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:

        def backtrack(start):

            if len(path) == k:
                res.append(path[:])
                return
            
            for i in range(start, n + 1):
                path.append(i)
                backtrack(i + 1)
                path.pop()
        
        path, res = [], []
        backtrack(1)

        return res
```



#### ✅[组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

```python
class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:

        def backtrack(start, sumpath):

            if sumpath > n: return 

            if len(path) == k and sumpath == n:
                result.append(path[:])
                return 
            
            # 剪枝 for i in range(start, 9 - k + len(path) + 2):  9 - (k - len(path)) + 1 + 1
            for i in range(start, 10): 
                path.append(i)
                backtrack(i + 1, sumpath + i)
                path.pop()

        result, path = [], []
        backtrack(1, 0)

        return result
```



#### ✅[电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

```Python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:

        def backtrack(start): # start指向下一个选的dights数字位置

            if start == len(digits): # 当start移动到n - 1，backtrack(start + 1)时，start == n
                res.append(''.join(path[:]))
                return
            
            for char in num2char[digits[start]]:
                path.append(char)
                backtrack(start + 1)
         []       path.pop()            
        
        num2char = {
            '2': ['a', 'b', 'c'],
            '3': ['d', 'e', 'f'],
            '4': ['h', 'i', 'g'],
            '5': ['j', 'k', 'l'],
            '6': ['m', 'n', 'o'],
            '7': ['p', 'q', 'r', 's'],
            '8': ['t', 'u', 'v'],
            '9': ['w', 'x', 'y', 'z']
        }

        res, path = [], []
        if not digits: return res
      
        backtrack(0)

        return res
```



#### ✅[组合总和](https://leetcode-cn.com/problems/combination-sum/)

```Python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:

        res, path = [], []

        def backtrack(start, sumpath):

            if sumpath > target:  # 剪枝
                return
            if sumpath == target:
                res.append(path[:])
                return

            for i in range(start, len(candidates)):
                path.append(candidates[i])
                backtrack(i, sumpath + candidates[i]) # 关键点:不用i+1了，表示candidates中的数字可以重复读取当前的数
                path.pop()
        
        backtrack(0, 0)

        return res
```



#### ✅[组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

**组合问题去重：**

- 本题数组**candidates的元素是有重复的**，上一题数组candidates的元素是无重复；
- **在搜索的过程中就去掉重复组合，所谓去重，其实就是使用过的元素不能重复选取，**都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。**没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因**；
- 回看一下题目：元素在同一个组合内是可以重复的，但两个组合不能相同，**所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重**；
- **树层去重的话，需要对数组排序**；

```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:

        res, path = [], []

        def backtrack(start, sumpath):
            
            if sumpath > target: return 
            if sumpath == target:
                res.append(path[:])
                return
            
            for i in range(start, len(candidates)):

                if i > start and candidates[i] == candidates[i - 1]: # 在树层方面去重
                    continue
                
                sumpath += candidates[i]
                path.append(candidates[i])
                backtrack(i + 1, sumpath) # 每个数字在组合中只能使用一次，但是数字可以重复
                sumpath -= path.pop()

        
        candidates = sorted(candidates)  # 树层去重，需要对数组排序
        backtrack(0, 0)

        return res
```



### 子集



- 如果把子集问题、组合问题、分割问题都抽象为一棵树的话，**「那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！」**
- 子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的，**那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！**有同学问了，什么时候for可以从0开始呢？求排列问题的时候，就要从0开始，因为集合是有序的，{1, 2} 和{2, 1}是两个集合，



#### ✅[子集](https://leetcode-cn.com/problems/subsets/)

```Python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:

        res, path = [], []

        def backtrack(start):
						# 遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合
            res.append(path[:])  # 收集子集，要放在终止添加的上面，否则会漏掉自己
            
            if start >= len(nums):
                return
            
            for i in range(start, len(nums)):
                path.append(nums[i])
                backtrack(i + 1)
                path.pop()
        
        backtrack(0)

        return res
```



#### ✅[子集 II](https://leetcode-cn.com/problems/subsets-ii/)

这道题目和[子集](https://mp.weixin.qq.com/s/NNRzX-vJ_pjK4qxohd_LtA)区别就是集合里有重复元素了，而且求取的子集要去重**（树层去重）**

```Python
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:

        def backtrack(start):
            
            res.append(path[:])

            if start >= len(nums):
                return
            
            for i in range(start, len(nums)):
                if i > start and nums[i] == nums[i - 1]:   #我们要对同一树层使用过的元素进行去重
                    continue
                path.append(nums[i])
                backtrack(i + 1) # 同一集合不需要去重
                path.pop()
        
        res, path = [], []
        nums.sort()
        backtrack(0)

        return res
```



#### ✅[递增子序列](https://leetcode-cn.com/problems/increasing-subsequences/)

- 在[子集II](https://mp.weixin.qq.com/s/WJ4JNDRJgsW3eUN72Hh3uQ)中我们是通过排序来达到去重的目的；
- 本题求自增子序列，是不能对原数组经行排序的，因为排完序的数组都是自增子序列了，**所以不能使用之前的去重逻辑；**
- **同一父节点下的同层上使用过的元素就不能在使用了**，每层使用set进行去重；

```python
class Solution:
    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        
        path, res = [], []

        def backtrack(start):
            
            if len(path) >= 2:
                res.append(path[:])
            
            if start >= len(nums):
                return 
            
            repeat = set()

            for i in range(start, len(nums)):
                if nums[i] in repeat: continue
                if path and nums[i] < path[-1]:  continue

                repeat.add(nums[i])
                path.append(nums[i])
                backtrack(i + 1)
                path.pop()
                

        backtrack(0)

        return res
```



### 分割



#### ✅[分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

```Python
class Solution:
    def partition(self, s: str) -> List[List[str]]:

        def backtrack(start):
            
            if start == len(s):
                res.append(path[:])
                return
            
            for i in range(start, len(s)):
                if s[start: i + 1] == s[start: i + 1][::-1]:
                    path.append(s[start: i + 1])
                else:
                    continue
                backtrack(i + 1)
                path.pop()
        
        res, path = [], []
        backtrack(0)

        return res
```



#### ✅[复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

```Python
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:

        def isVaildNumber(s, start, end):
            
            if not s[start: end + 1]:  # 必须由数字组成
                return False
            elif s[start] == '0' and start != end:
                return False
            elif int(s[start: end + 1]) < 0 or int(s[start: end + 1]) > 255:
                return False
            else:
                return True

        def backtrack(start):
            if len(path) == 4 and start == len(s):
                res.append('.'.join(path[:]))
                return
            for i in range(start, len(s)):
                if isVaildNumber(s, start, i):
                    path.append(s[start: i + 1])
                    backtrack(i + 1)
                    path.pop()
                else:
                    break                                                       

        if len(s) < 4 or len(s) > 12:
            return res 
            
        backtrack(0)
        res, path = [], []

        return res
```

s

#### ✅[将数组分成和相等的三个部分](https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum/)

```python
class Solution:
    def canThreePartsEqualSum(self, arr: List[int]) -> bool:

        sumarr = sum(arr)
        if sumarr % 3 == 1: return False
        part = sumarr // 3
        res, curpart = [], 0

        for i in range(len(arr)):
            curpart += arr[i]
            if curpart == part:
                res.append(curpart)   # 第一段求出后,加入数组,和清零
                curpart = 0
                if len(res) == 2 and i != len(arr) - 1:   # 求出前两部分和后,求第三部分
                    c = sum(arr[i + 1:])
                    res.append(c)
                    return res[0] == res[1] == res[2]
        
        return False
```



### 排列



- **排列是有序的，也就是说[1,2] 和[2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方**，可以看出元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1，所以处理排列问题就不用使用startIndex了；
- 子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的，**那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！**有同学问了，什么时候for可以从0开始呢？求排列问题的时候，就要从0开始，因为集合是有序的，{1, 2} 和{2, 1}是两个集合；
- 排列问题需要一个used数组，标记已经选择的元素；



#### ✅[全排列](https://leetcode-cn.com/problems/permutations/)

```Python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:

        res, path = [], []

        def backtrack(used):
            
            if len(path) == len(nums):
                res.append(path[:])
                return
            
            for i in range(len(nums)):
                if used[i]:  continue
                path.append(nums[i])
                used[i] = True
                backtrack(used)
                path.pop()
                used[i] = False                    

        used = [False for _ in range(len(nums))]
        backtrack(used)

        return res
```



#### ✅[全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

- 这道题目和[排列](https://mp.weixin.qq.com/s/SCOjeMX1t41wcvJq49GhMw)的区别在与**给定一个可包含重复数字的序列**，要返回**所有不重复的全排列；**
- 在[组合总和II](https://mp.weixin.qq.com/s/_1zPYk70NvHsdY8UWVGXmQ) 、[子集II](https://mp.weixin.qq.com/s/WJ4JNDRJgsW3eUN72Hh3uQ)我们分别详细讲解了组合问题和子集问题如何去重，那么排列问题其实也是一样的套路。**还要强调的是去重一定要对元素经行排序，这样我们才方便通过相邻的节点来判断是否重复使用了**；

```Python
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:

        def backtrack(used):
            
            if len(path) == len(nums):
                res.append(path[:])
                return

            for i in range(len(nums)):
                if not used[i]:
                   # 我们对同一树层，前一位（也就是nums[i-1]）如果使用过，那么就进行去重 
                    if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:
                        continue
                    
                    path.append(nums[i])
                    used[i] = True
                    backtrack(used)
                    path.pop() 
                    used[i] = False               
        
        res, path = [], []
        nums.sort()
        used = [False for _ in range(len(nums))]
        backtrack(used)

        return res
```



#### ✅[给定数字能组成的最大时间](https://leetcode-cn.com/problems/largest-time-for-given-digits/)

```python
class Solution:
    def largestTimeFromDigits(self, arr: List[int]) -> str:
        
        arr.sort(reverse=True)
        for a, b, c, d in permutations(arr):
            if 0 <= (10 * a + b) < 24 and 0 <= (10 * c + d) < 60:
                return f"{a}{b}:{c}{d}"
        
        return ""
```

```python
class Solution:
    def largestTimeFromDigits(self, arr: List[int]) -> str:

        def backtrack(used):
            if len(path) == 4:
                if 0 <= (path[0] * 10 + path[1]) < 24 and 0 <= (path[2] *10 + path[3]) < 60:
                    res.append(path[:])
                    return True
                else:
                    return False
            
            for i in range(len(arr)):
                if used[i]:  continue
                path.append(arr[i])
                used[i] = True
                if backtrack(used):
                    return 
                path.pop()
                used[i] = False
            
        
        path, res = [], []
        used = [False for _ in range(len(arr))]
        arr.sort(reverse=True)
        backtrack(used)

        return str(res[0][0]) + str(res[0][1]) + ":" + str(res[0][2]) + str(res[0][3]) if res else ""
```



#### ✅路径规划

某公司有M个园区，从0-M-1编号，已知两个园区距离，描述如下：

0， 1， 3表示从0到1号园区距离为3（1到0距离也为3），已知N段距离，未给出的距离不可达，现有一个员工想从A区出发，走遍所有园区，同一园区只能经过一次，计算最短距离

```python
# 输入
m, start, n = map(int, input().strip().split(' '))
distance = []
for _ in range(n):
    line = list(map(int, input().strip().split(' ')))
    distance.append(line)

# 构造距离矩阵matrix，used数组
matrix = [[float("inf") for _ in range(m)] for _ in range(m)]
used = [False for _ in range(m)]
for s, e, w in distance:
    matrix[s][e] = w
    matrix[e][s] = w


def check(used):
    for i in range(m):
        if not iused[i]:
            return False
    return True


def dfs(start, matrix, used, dis):
    global mindis
    if check(used):
        mindis = min(dis, mindis)
        return
    for i in range(m):
        if not used[i] and matrcheix[start][i] != float("inf"):
            used[i] = True
            dfs(i, matrix, used, dis + matrix[start][i])
            used[i] = False

mindis = float("inf")
used[start] = True
dfs(start, matrix, used, 0)
print(-1 if mindis == float("inf") else mindis)
```



### 棋盘问题

#### [N 皇后](https://leetcode-cn.com/problems/n-queens/)

- 皇后们的约束条件：1.不能同行 2.不能同列 3.不能同斜线
- 搜索皇后的位置，可以抽象为一棵树，那么我们用皇后们的约束条件，来回溯搜索这颗树，**只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了**



![51.N皇后](https://camo.githubusercontent.com/b662efc3d23bb487d910e79df9c8dcd5a4bc8d3c73e4a96bda8717cce5038856/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303133303138323533323330332e6a7067)

```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:

        res, board = [], [['.' for _ in range(n)] for _ in range(n)]

        def isVaild(board, row, col):
            #判断同一列是否冲突,为什么没有在同行进行检查呢？因为在单层搜索的过程中，每一层递归，只会选for循环（也就是同一行）里的一个元素
            for i in range(len(board)):
                if board[i][col] == 'Q':
                    return False
                    
            # 判断左上角是否冲突
            i, j = row - 1, col - 1
            while i >= 0 and j >= 0:
                if board[i][j] == 'Q':
                    return False
                i -= 1
                j -= 1
            # 判断右上角是否冲突
            i = row - 1
            j = col + 1
            while i >= 0 and j < len(board):
                if board[i][j] == 'Q':
                    return False
                i -= 1
                j += 1
            
            return True

        
        def backtrack(board, row):
            # 如果走到最后一行，说明已经找到一个解
            if row == n:
                tmpres = []
                for temp in board:
                    temp_str = "".join(temp)
                    tmpres.append(temp_str)
                res.append(tmpres)
            
            for col in range(n):
                if not isVaild(board, row, col):
                    continue
                board[row][col] = 'Q'
                backtrack(board, row + 1)
                board[row][col] = '.' 
        
        backtrack(board, 0)

        return res
```



#### [解数独](https://leetcode-cn.com/problems/sudoku-solver/)

```python
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:

        def isValid(row, col, val, board):
            
            for j in range(9): #判断行里是否重复
                if board[row][j] == str(val): return False
            
            for i in range(9): #判断列里是否重复
                if board[i][col] == str(val): return False
            
            startrow, startcol = (row // 3) * 3 , (col // 3) * 3
            for i in range(startrow, startrow + 3):
                for j in range(startcol, startcol + 3):
                    if board[i][j] == str(val): return False
            
            return True

        
        def backtrack(board):
            
            for i in range(len(board)): #遍历行
                for j in range(len(board[0])):#遍历列
                    if board[i][j] != ".":  continue
                    for k in range(1, 10):#(i, j) 这个位置放k是否合适
                        if isValid(i, j, k, board):
                            board[i][j] = str(k) #放置k
                            if backtrack(board): return True # 递归的下一层的棋盘一定比上一层的棋盘多一个数，等数填满了棋盘自然就终止（填满当然好了，说明找到结果了），所以不需要终止条件！如果找到合适一组立刻返回
                            board[i][j] = "." #回溯，撤销k
                    return False #9个数都试完了，都不行，那么就返回false
            return True  #遍历完没有返回false，说明找到了合适棋盘位置了
        
        backtrack(board)
```



### 其他

#### [重新安排行程](https://leetcode-cn.com/problems/reconstruct-itinerary/)

**难点：**

- 一个行程中，如果航班处理不好容易变成一个圈，成为死循环；
- 有多种解法，字母序靠前排在前面，如何该记录映射关系；
- 使用回溯法终止条件是什么；
- 搜索的过程中，如何遍历一个机场所对应的所有机场；

```python
class Solution:
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:

        tickets_dict = defaultdict(list)
        for item in tickets:
            tickets_dict[item[0]].append(item[1])
        
        path = ["JFK"]

        def backtrack(start_point):

            if len(path) == len(tickets) + 1:
                return True

            tickets_dict[start_point].sort()

            for _ in tickets_dict[start_point]:
                end_point = tickets_dict[start_point].pop(0)
                path.append(end_point)

                if backtrack(end_point):
                    return True
                
                path.pop()
                tickets_dict[start_point].append(end_point)
        
        backtrack("JFK")
        # 数返回值都是bool呢？因为我们只需要找到一个行程，就是在树形结构中唯一的一条通向叶子节点的路线
        return path
```

