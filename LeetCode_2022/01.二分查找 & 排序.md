#### ✅[在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

模板 2 

```Python
class Solution:
    def searchRange(self, nums, target):
        
        Range = [-1, -1]
        
        if not nums:
            return Range
        
        # 找左边第一次出现
        l, r = 0, len(nums) - 1
        while l < r:
            mid = l + (r - l) // 2
            if nums[mid] < target:
                l = mid + 1
            else:
                r = mid

        if nums[l] == target:
            Range[0] = l 
        else: # 左边都找不到，nums中没有target
            return Range 
        
        # 找右边第一次出现
        l, r = 0, len(nums) - 1
        while l < r:
            mid = l + (r - l + 1) // 2 
            if nums[mid] > target:
                r = mid - 1
            else:
                l = mid
            
        Range[1] = r # 由于能走到这里，说明在数组中一定找得到目标元素，因此这里不用再做一次判断
        
        return Range
```



#### ✅[ x 的平方根 ](https://leetcode.cn/problems/sqrtx/)

```python
class Solution:
    def mySqrt(self, x: int) -> int:

        l, r = 0, x

        while l <= r:
            mid = l + (r - l) // 2
            cur_pow = mid ** 2
            if cur_pow == x:
                return mid
            elif cur_pow > x:
                r = mid - 1
            else:
                l = mid + 1
        
        return r  # 查找失败时，r为最后一个小于math.sqrt(x)的整数
```



#### ✅[寻找峰值](https://leetcode.cn/problems/find-peak-element/)

```python
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        l, r = 0, len(nums) - 1

        while l < r:
            mid = l + (r - l) // 2
            # 如果你往下坡方向走，也许可能遇到新的山峰，但是也许是一个一直下降的坡，最后到边界;但是如果你往上坡方向走，就算最后一直上的边界，由于最边界是负无穷，所以就一定能找到山峰.总的一句话，往递增的方向上，二分，一定能找到，往递减的方向只是可能找到，也许没有;
            if nums[mid] < nums[mid+1]:
                l = mid + 1
            else:
                r = mid
        
        return l
```



#### ✅[搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix/)

模板1

```Python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        # 两次二分，首先定位行数，接着定位列数
        
        l, r = 0, len(matrix) - 1
        
        while l <= r:
            mid = l + (r - l) // 2
            if matrix[mid][0] == target:
                return True
            elif matrix[mid][0] < target:
                l = mid + 1
            else:
                r = mid - 1
        
        row = r  # 搜索失败l是第一个大于target的位置，但是如果我们要找target，matrix[r][0]已经大于target了，所以如果有可能的话只可能在matrix[r]这一行
        l, r = 0, len(matrix[0]) - 1
        while l <= r:
            mid = l + (r - l) // 2
            if matrix[row][mid] == target:
                return True
            elif matrix[row][mid] < target:
                l = mid + 1
            else:
                r = mid - 1
        
        return False
```

模板2

```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
      

        l, r = 0, len(matrix) - 1
        while l < r:
            mid = l + (r -l) // 2
            if matrix[mid][0] < target:
                l = mid + 1
            else:
                r = mid
        if matrix[l][0] == target:
            return True
        
        row = l if target > matrix[l][0] else l - 1 #当matrix[l][0] < target时候，target和matrix[l][0]在同一行

        l, r = 0, len(matrix[0]) - 1
        while l < r:
            mid = l + (r - l) // 2
            if matrix[row][mid] < target:
                l = mid + 1
            else:
                r = mid
        
        if matrix[row][l] == target:
            return True

        return False
```



#### ✅[搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
          
        row, col = 0, len(matrix[0]) - 1

        while row < len(matrix) and col >= 0:
            if matrix[row][col] == target:
                return True
            elif matrix[row][col] > target:
                col -= 1
            else:
                row += 1
        
        return False
```



#### ✅[寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

- 模板2，**当中间元素大于右侧元素时意味着拐点即最小元素在右侧**，否则在左侧

```Python
class Solution:
    def findMin(self, nums: List[int]) -> int:  # 元素值互不相同的数组 nums
        
        l , r = 0, len(nums) - 1
        
        while l < r:
            mid = l + (r - l) // 2
            if nums[mid] > nums[r]:
                l = mid + 1
            else:
                r = mid
        
        return nums[l]
```



#### ✅[寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)

- **数组部分有序，且包含重复元素：**当我们找到目标元素的时候（`nums[mid] = nus[r]`），向左收缩右边界不能简单的令` r = mid`，因为有重复元素的存在，这会导致我们有可能遗漏掉一部分区域。此时需要采用比较保守的方式即` right -= 1`；

```Python
class Solution:
    def findMin(self, nums: List[int]) -> int:   # 可能存在重复元素值的数组 nums 
      
        l, r = 0, len(nums) - 1
        
        while l < r:
            mid = l + (r - l) // 2
            if nums[mid] > nums[r]:  # 当中间元素大于右侧元素时意味着拐点即最小元素在右侧
                l = mid + 1
            elif nums[mid] < nums[r]: # 当中间元素小于右侧元素时意味着拐点即最小元素在左侧，左边界mid会分在左边
                r = mid
            else:
                r -= 1 # nums[r]=nums[mid]，没办法判断，r往前移，然后判断
                
        return nums[l]
```



#### ✅[搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

- 对于有序数组，可以使用二分查找的方法查找元素；但是这道题中数组本身不是有序的，进行旋转后只保证了数组的**局部是有序的**。


- 可以发现的是，我们**将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的**。拿示例来看，我们从 6 这个位置分开以后数组变成了 [4, 5, 6] 和 [7, 0, 1, 2] 两个部分，其中左边 [4, 5, 6] 这个部分的数组是有序的，其他也是如此；
- 启示我们可以在常规二分查找的时候查看当前 mid 为分割位置分割出来的两个部分 [l, mid] 和 [mid + 1, r] 哪个部分是有序的，并根据有序的那个部分确定我们该如何改变二分查找的上下界，因为我们能够根据有序的那部分判断出 target 在不在这个部分：

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:

        l, r = 0, len(nums) - 1

        while l <= r:
            mid = l + (r - l) // 2
            if nums[mid] == target: return mid 
            #左边有序
            elif  nums[l] <= nums[mid]: # 注意这个等号，加这个等号主要是为了防止只有两个数的时候出错：如果不加等号，两个数经过旋转，最后一个数要是就是target的话，不加等号就会直接进入右边有序分支，永远找不到, 然后在第二个条件中直接会让r = mid - 1。舍弃了正确答案，举例[3, 1],target=1            
                if nums[l] <= target < nums[mid]:  # 确定nums[mid] != target
                    r = mid - 1
                else:
                    l = mid + 1
            # 右边有序
            else: 
                if nums[mid] < target <= nums[r]:  # 确定nums[mid] != target
                    l = mid + 1
                else:
                    r = mid - 1
                    
        return -1
```



#### ✅[搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)

- 对于数组中有重复元素的情况，二分查找时可能会有 a[l]=a[mid]=a[r]，此时无法判断区间 [l,mid] 和区间 [mid+1,r] 哪个是有序的；例如 nums=[3,1,2,3,3,3,3]，target=2，首次二分时无法判断区间 [0,3] 和区间 [4,6] 哪个有序。对于这种情况，我们只能将当前二分区间的左边界加一，右边界减一，然后在新区间上继续二分查找；

```Python
class Solution:
    def search(self, nums: List[int], target: int) -> bool:

        l, r = 0, len(nums) - 1

        while l <= r:
            mid = l + (r - l) // 2
            if nums[mid] == target: return True
            if nums[l] == nums[mid] == nums[r]:  #增加了l， mid， r情况需要处理
                l += 1
                r -= 1

            elif nums[l] <= nums[mid]: # 左边有序
                if nums[l] <= target < nums[mid]:
                    r = mid - 1
                else:
                    l = mid + 1

            else:   # 右边有序
                if nums[mid] < target <= nums[r]:
                    l = mid + 1
                else:
                    r = mid - 1
                    
        return False
```



## 2. [数组排序](https://leetcode-cn.com/problems/sort-an-array/)



- [十大经典排序](https://www.cnblogs.com/onepixel/p/7674659.html)
- 数据很多时：**先使用快排**对数据集进行排序，此时的数据集已经达到了基本有序的状态，然后当分区的规模达到一定小时便停止快速排序算法，而是改用**插入排序**，因为插入排序在对基本有序的数据集排序有着接近线性的复杂度；

![img](https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png)



### 2.1 快速排序

```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:  # 入口
        
        self.quicksort(nums, 0, len(nums) - 1)
        
        return nums
    

    def quicksort(self, nums, left, right):

        if left >= right:  return 

        pos = self.partation(nums, left, right)
        self.quicksort(nums, left, pos - 1)
        self.quicksort(nums, pos + 1, right)
    
    def partation(self, nums, left, right):
        
        pivot = randint(left, right)  # 随机选择基准， 然后和right位置元素交换，使得right位置为基准，要不然有时候会超时
        nums[pivot], nums[right] = nums[right], nums[pivot]
        pre_min_povit = left - 1  # pre_min_povit记录上一个小于基准的位置

        for cur_pos in range(left,  right):  # cur_pos作为当前指针使用，如果找到小于基准，则把pre_min_povit += 1，然后互换位置，因为pre_min_povit记录上一个小于基准的位置，所以在pre_min_povit之后，cur_pos之前元素都大于基准
            if nums[cur_pos] < nums[right]:
                pre_min_povit += 1
                nums[cur_pos], nums[pre_min_povit] = nums[pre_min_povit], nums[cur_pos]
        
        pre_min_povit += 1
        nums[pre_min_povit], nums[right] = nums[right], nums[pre_min_povit]  # 将povit放到正确位置上

        return pre_min_povit
```



### 2.2 归并排序

```Python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:

        return self.mergesort(nums)
    

    def mergesort(self, nums):

        n = len(nums)
        if n <= 1:  return nums  # 归并排序必须返回值给lft_part和right_part
        
        mid = n // 2

        left_part = self.mergesort(nums[:mid])
        right_part = self.mergesort(nums[mid:])

        return self.merge(left_part, right_part)
    

    def merge(self, left_part, right_part):
        
        merged = []
        idx_left, idx_right = 0, 0

        while idx_left < len(left_part) and idx_right < len(right_part):
            if left_part[idx_left] < right_part[idx_right]:
                merged.append(left_part[idx_left])
                idx_left += 1
            else:
                merged.append(right_part[idx_right])
                idx_right += 1
        
        # 必定有一个后面是空的
        merged += left_part[idx_left:]  
        merged += right_part[idx_right:] 

        return merged
```



### 2.3 堆排序

```Python
class Solution:
    def max_heapify(self, heap, root, heap_len):
        
        p = root  # 当前节点
        while p * 2 + 1 < heap_len:  # 确保左边子节点存在
            l, r = p * 2 + 1, p * 2 + 2
            # nex代表左右最大值的节点
            if heap_len > r and heap[r] > heap[l]: 
                nex = r
            else:
                nex = l
            if heap[p] < heap[nex]:
                heap[p], heap[nex] = heap[nex], heap[p]
                p = nex
            else:
                break
        
    def build_heap(self, heap):
        for i in range(len(heap) - 1, -1, -1):
            self.max_heapify(heap, i, len(heap))  # 建堆时i节点为根结点 

    def sortArray(self, nums):
        
        self.build_heap(nums)
        for i in range(len(nums) - 1, -1, -1):
            nums[i], nums[0] = nums[0], nums[i]
            self.max_heapify(nums, 0, i)  # 大根堆0位置为最大元素，交换后时i位置之后都排好序了，所以以0位置为根，堆长度为i 
            
        return nums
```



## 3. 数组矩阵模拟



### 3.1 题目

#### ✅[螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
      
        if not len(matrix) or not len(matrix[0]):
            return []
        
        rows, columns = len(matrix), len(matrix[0])
        order = []
        left, right, top, bottom = 0, columns - 1, 0, rows - 1
        
        while left <= right and top <= bottom:
            for column in range(left, right + 1):
                order.append(matrix[top][column])
            for row in range(top + 1, bottom + 1):
                order.append(matrix[row][right])
            if left < right and top < bottom: # 排除rows=1或者columns=1情况，以及最后一行或者一列时候的输出
                for column in range(right - 1, left, -1):
                    order.append(matrix[bottom][column])
                for row in range(bottom, top, -1):
                    order.append(matrix[row][left])
                    
            left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1
            
        return order
```

#### [螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)



#### [路径交叉](https://leetcode-cn.com/problems/self-crossing/)

```python

```

