

### 2.1 快速排序

```python

```



### 2.2 归并排序

```Python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:

        return self.mergesort(nums)
    

    def mergesort(self, nums):

        n = len(nums)
        if n <= 1:  return nums  # 归并排序必须返回值给lft_part和right_part
        
        mid = n // 2

        left_part = self.mergesort(nums[:mid])
        right_part = self.mergesort(nums[mid:])

        return self.merge(left_part, right_part)
    

    def merge(self, left_part, right_part):
        
        merged = []
        idx_left, idx_right = 0, 0

        while idx_left < len(left_part) and idx_right < len(right_part):
            if left_part[idx_left] < right_part[idx_right]:
                merged.append(left_part[idx_left])
                idx_left += 1
            else:
                merged.append(right_part[idx_right])
                idx_right += 1
        
        # 必定有一个后面是空的
        merged += left_part[idx_left:]  
        merged += right_part[idx_right:] 

        return merged
```



### 2.3 堆排序

```Python
class Solution:
    def max_heapify(self, heap, root, heap_len):
        
        p = root  # 当前节点
        while p * 2 + 1 < heap_len:  # 确保左边子节点存在
            l, r = p * 2 + 1, p * 2 + 2
            # nex代表左右最大值的节点
            if heap_len > r and heap[r] > heap[l]: 
                nex = r
            else:
                nex = l
            if heap[p] < heap[nex]:
                heap[p], heap[nex] = heap[nex], heap[p]
                p = nex
            else:
                break
        
    def build_heap(self, heap):
        for i in range(len(heap) - 1, -1, -1):
            self.max_heapify(heap, i, len(heap))  # 建堆时i节点为根结点 

    def sortArray(self, nums):
        
        self.build_heap(nums)
        for i in range(len(nums) - 1, -1, -1):
            nums[i], nums[0] = nums[0], nums[i]
            self.max_heapify(nums, 0, i)  # 大根堆0位置为最大元素，交换后时i位置之后都排好序了，所以以0位置为根，堆长度为i 
            
        return nums
```







