



#### ✅[搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

- 对于有序数组，可以使用二分查找的方法查找元素；但是这道题中数组本身不是有序的，进行旋转后只保证了数组的**局部是有序的**。


- 可以发现的是，我们**将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的**。拿示例来看，我们从 6 这个位置分开以后数组变成了 [4, 5, 6] 和 [7, 0, 1, 2] 两个部分，其中左边 [4, 5, 6] 这个部分的数组是有序的，其他也是如此；
- 启示我们可以在常规二分查找的时候查看当前 mid 为分割位置分割出来的两个部分 [l, mid] 和 [mid + 1, r] 哪个部分是有序的，并根据有序的那个部分确定我们该如何改变二分查找的上下界，因为我们能够根据有序的那部分判断出 target 在不在这个部分：

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:

        l, r = 0, len(nums) - 1

        while l <= r:
            mid = l + (r - l) // 2
            if nums[mid] == target: return mid 
            #左边有序
            elif  nums[l] <= nums[mid]: # 注意这个等号，加这个等号主要是为了防止只有两个数的时候出错：如果不加等号，两个数经过旋转，最后一个数要是就是target的话，不加等号就会直接进入右边有序分支，永远找不到, 然后在第二个条件中直接会让r = mid - 1。舍弃了正确答案，举例[3, 1],target=1            
                if nums[l] <= target < nums[mid]:  # 确定nums[mid] != target
                    r = mid - 1
                else:
                    l = mid + 1
            # 右边有序
            else: 
                if nums[mid] < target <= nums[r]:  # 确定nums[mid] != target
                    l = mid + 1
                else:
                    r = mid - 1
                    
        return -1
```



#### ✅[搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)

- 对于数组中有重复元素的情况，二分查找时可能会有 a[l]=a[mid]=a[r]，此时无法判断区间 [l,mid] 和区间 [mid+1,r] 哪个是有序的；例如 nums=[3,1,2,3,3,3,3]，target=2，首次二分时无法判断区间 [0,3] 和区间 [4,6] 哪个有序。对于这种情况，我们只能将当前二分区间的左边界加一，右边界减一，然后在新区间上继续二分查找；

```Python
class Solution:
    def search(self, nums: List[int], target: int) -> bool:

        l, r = 0, len(nums) - 1

        while l <= r:
            mid = l + (r - l) // 2
            if nums[mid] == target: return True
            if nums[l] == nums[mid] == nums[r]:  #增加了l， mid， r情况需要处理
                l += 1
                r -= 1

            elif nums[l] <= nums[mid]: # 左边有序
                if nums[l] <= target < nums[mid]:
                    r = mid - 1
                else:
                    l = mid + 1

            else:   # 右边有序
                if nums[mid] < target <= nums[r]:
                    l = mid + 1
                else:
                    r = mid - 1
                    
        return False
```



## 2. [数组排序](https://leetcode-cn.com/problems/sort-an-array/)



- [十大经典排序](https://www.cnblogs.com/onepixel/p/7674659.html)
- 数据很多时：**先使用快排**对数据集进行排序，此时的数据集已经达到了基本有序的状态，然后当分区的规模达到一定小时便停止快速排序算法，而是改用**插入排序**，因为插入排序在对基本有序的数据集排序有着接近线性的复杂度；

![img](https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png)



### 2.1 快速排序

```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:  # 入口
        
        self.quicksort(nums, 0, len(nums) - 1)
        
        return nums
    

    def quicksort(self, nums, left, right):

        if left >= right:  return 

        pos = self.partation(nums, left, right)
        self.quicksort(nums, left, pos - 1)
        self.quicksort(nums, pos + 1, right)
    
    def partation(self, nums, left, right):
        
        pivot = randint(left, right)  # 随机选择基准， 然后和right位置元素交换，使得right位置为基准，要不然有时候会超时
        nums[pivot], nums[right] = nums[right], nums[pivot]
        pre_min_povit = left - 1  # pre_min_povit记录上一个小于基准的位置

        for cur_pos in range(left,  right):  # cur_pos作为当前指针使用，如果找到小于基准，则把pre_min_povit += 1，然后互换位置，因为pre_min_povit记录上一个小于基准的位置，所以在pre_min_povit之后，cur_pos之前元素都大于基准
            if nums[cur_pos] < nums[right]:
                pre_min_povit += 1
                nums[cur_pos], nums[pre_min_povit] = nums[pre_min_povit], nums[cur_pos]
        
        pre_min_povit += 1
        nums[pre_min_povit], nums[right] = nums[right], nums[pre_min_povit]  # 将povit放到正确位置上

        return pre_min_povit
```



### 2.2 归并排序

```Python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:

        return self.mergesort(nums)
    

    def mergesort(self, nums):

        n = len(nums)
        if n <= 1:  return nums  # 归并排序必须返回值给lft_part和right_part
        
        mid = n // 2

        left_part = self.mergesort(nums[:mid])
        right_part = self.mergesort(nums[mid:])

        return self.merge(left_part, right_part)
    

    def merge(self, left_part, right_part):
        
        merged = []
        idx_left, idx_right = 0, 0

        while idx_left < len(left_part) and idx_right < len(right_part):
            if left_part[idx_left] < right_part[idx_right]:
                merged.append(left_part[idx_left])
                idx_left += 1
            else:
                merged.append(right_part[idx_right])
                idx_right += 1
        
        # 必定有一个后面是空的
        merged += left_part[idx_left:]  
        merged += right_part[idx_right:] 

        return merged
```



### 2.3 堆排序

```Python
class Solution:
    def max_heapify(self, heap, root, heap_len):
        
        p = root  # 当前节点
        while p * 2 + 1 < heap_len:  # 确保左边子节点存在
            l, r = p * 2 + 1, p * 2 + 2
            # nex代表左右最大值的节点
            if heap_len > r and heap[r] > heap[l]: 
                nex = r
            else:
                nex = l
            if heap[p] < heap[nex]:
                heap[p], heap[nex] = heap[nex], heap[p]
                p = nex
            else:
                break
        
    def build_heap(self, heap):
        for i in range(len(heap) - 1, -1, -1):
            self.max_heapify(heap, i, len(heap))  # 建堆时i节点为根结点 

    def sortArray(self, nums):
        
        self.build_heap(nums)
        for i in range(len(nums) - 1, -1, -1):
            nums[i], nums[0] = nums[0], nums[i]
            self.max_heapify(nums, 0, i)  # 大根堆0位置为最大元素，交换后时i位置之后都排好序了，所以以0位置为根，堆长度为i 
            
        return nums
```



## 3. 数组矩阵模拟



### 3.1 题目

#### ✅[螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
      
        if not len(matrix) or not len(matrix[0]):
            return []
        
        rows, columns = len(matrix), len(matrix[0])
        order = []
        left, right, top, bottom = 0, columns - 1, 0, rows - 1
        
        while left <= right and top <= bottom:
            for column in range(left, right + 1):
                order.append(matrix[top][column])
            for row in range(top + 1, bottom + 1):
                order.append(matrix[row][right])
            if left < right and top < bottom: # 排除rows=1或者columns=1情况，以及最后一行或者一列时候的输出
                for column in range(right - 1, left, -1):
                    order.append(matrix[bottom][column])
                for row in range(bottom, top, -1):
                    order.append(matrix[row][left])
                    
            left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1
            
        return order
```

#### [螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)



#### [路径交叉](https://leetcode-cn.com/problems/self-crossing/)

```python

```

