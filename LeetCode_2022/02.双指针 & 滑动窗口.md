



#### [最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/) 【最大滑窗】

```python
class Solution:
    def longestOnes(self, nums: List[int], k: int) -> int:  

        l, r = 0, 0
        zero_cnt, max_len = 0, 0  # zero_cnt记录翻转0个数，max_len记录最长连续1长度

        while r < len(nums):
          
            if nums[r] == 0:
                zero_cnt += 1
            
            while zero_cnt > k:  # 最大滑窗，不满足条件
                
                if nums[l] == 0:
                    zero_cnt -= 1
                
                l += 1
            
            # 满足条件更新
            max_len = max(max_len, r - l + 1)
            r += 1
        
        return max_len
```



#### [无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/) 【最大滑窗】

```Python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:

        l, r = 0, 0
        last_idx, max_len = {}, 0  # last_idx存储上一个元素出现的位置

        while r < len(s):

            if s[r] in last_idx and last_idx[s[r]] >= l:  # s[r]记录在last_idx中并且r位置在l右侧，此时s[r]元素出现重复
                max_len = max(max_len, r - l)
                l = last_idx[s[r]] + 1 # 滑动窗口，只不过左端不需要收缩，用s[r]上一次出现位置 + 1代替了l += 1操作，这样l缩小速度变快了，一步到位可以计算出当前不重复子串长度
            
            last_idx[s[r]] = r
            r += 1
        
        return max(max_len, r - l)  # 若最后一个s子串各不相同，此时这最后一个子串没有加入到max_len
```



#### ✅[滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

- **大根堆**可以帮助我们实时维护一系列元素中的最大值；
- 初始时，我们将数组nums 的前 k 个元素放入优先队列中；**每当我们向右移动窗口时，我们就可以把一个新的元素放入优先队列中，此时堆顶的元素就是堆中所有元素的最大值**，然而这个最大值可能并不在滑动窗口中，**在这种情况下，这个值在数组nums 中的位置出现在滑动窗口左边界的左侧**。，因此当我们后续继续向右移动窗口时，这个值就永远不可能出现在滑动窗口中了，我们可以将其永久地从优先队列中移除；
- **我们不断地移除堆顶的元素，直到其确实出现在滑动窗口中，此时，堆顶元素就是滑动窗口中的最大值**。为了方便判断堆顶元素与滑动窗口的位置关系，我们可以**在优先队列中存储二元组(num,index)**，表示元素 num 在数组中的下标为index；

```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:

        max_heap = [(-(nums[i]), i) for i in range(k)]  # python默认最小堆
        heapq.heapify(max_heap)
        res = [-max_heap[0][0]]

        for i in range(k, len(nums)):
            heapq.heappush(max_heap, (-nums[i], i))
            while max_heap[0][1] <= i - k: # 最大值在窗口外
                heapq.heappop(max_heap)
            res.append(-max_heap[0][0])
        
        return res
```

