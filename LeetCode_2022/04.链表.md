









#### 



#### ✅[合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

```python
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:

        if not lists: return 

        min_heap = []  # heapq默认最小堆

        for curlist in lists:
            while curlist:
                heapq.heappush(min_heap, curlist.val)
                curlist = curlist.next
        
        dummy = ListNode()
        cur = dummy

        while min_heap:
            tmp = ListNode(heapq.heappop(min_heap))
            cur.next = tmp
            cur = tmp
        
        return dummy.next
```



#### ✅[分隔链表](https://leetcode-cn.com/problems/partition-list/)

```python
class Solution:
    def partition(self, head: ListNode, x: int) -> ListNode:
        #  只需维护两个链表,将小于 x 的节点，放到一个链表；将大于等于 x 的节点，放到另外一个链表，最后连接这两个链表；
        if not head or not head.next:
            return head

        dummy1, dummy2 = ListNode(), ListNode()
        cur1, cur2, cur = dummy1, dummy2, head

        while cur:
            if cur.val < x:
                cur1.next = cur
                cur1 = cur1.next
            else:
                cur2.next = cur
                cur2 = cur2.next
            cur = cur.next
        
        cur1.next = dummy2.next
        cur2.next = None

        return dummy1.next
```



#### ✅[两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

```Python
class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        
        new_head = head.next
        head.next = self.swapPairs(new_head.next)
        new_head.next = head

        return new_head
```



#### ✅[K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

```python
class Solution:
    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        # 找到下一组k的起始位置，如果小于k个直接返回head
        nextkhead = head
        for _ in range(k):
            if not nextkhead: return head
            nextkhead = nextkhead.next
        # 翻转k个
        pre, cur = None, head
        while cur != nextkhead:
            tmp = cur.next
            cur.next = pre
            pre, cur = cur, tmp
        newhead = pre
        # 递归下一组k个链表翻转，并连接到head.next
        head.next = self.reverseKGroup(nextkhead, k)

        return newhead
```



#### ✅[排序链表](https://leetcode-cn.com/problems/sort-list/)

- 思路：归并排序(自顶向下)，对链表自顶向下归并排序的过程如下:

  1. **找到链表的中点，以中点为分界，将链表拆分成两个子链表**：寻找链表的中点可以使用快慢指针的做法，快指针每次移动2 步，慢指针每次移动 1 步，当快指针到达链表末尾时，慢指针指向的链表节点即为链表的中点；
  2. **对两个子链表分别排序**：将两个排序后的子链表合并，得到完整的排序后的链表。可以使用「21. 合并两个有序链表」的做法，将两个有序的子链表进行合并；
  3. 上述过程可以通过递归实现，递归的终止条件是链表的节点个数小于或等于1，即**当链表为空或者链表只包含 1 个节点时，不需要对链表进行拆分和排序**；

```Python
class Solution:

    def mid(self, head):
        slow = fast = head
        while fast.next and fast.next.next:
            slow = slow.next
            fast = fast.next.next
        return slow
        

    def sortList(self, head: ListNode) -> ListNode:
        
        if not head or not head.next:
            return head

        mid = self.mid(head)
        l1, l2 = head, mid.next
        mid.next = None

        return self.merge(self.sortList(l1), self.sortList(l2))

    
    def merge(self, l1, l2):

        dummy_node = ListNode()

        cur = dummy_node

        while l1 and l2:
            if l1.val < l2.val:
                cur.next = l1
                l1 = l1.next
            else:
                cur.next = l2
                l2 = l2.next
            cur = cur.next
        
        cur.next = l1 if l1 else l2

        return dummy_node.next
```



#### ✅[重排链表](https://leetcode-cn.com/problems/reorder-list/)

```Python
class Solution:
    def reorderList(self, head: ListNode) -> None:  # 找到中点断开，翻转后面部分，然后合并前后两个链表

        if not head.next:
            return 
        
        mid = self.midNode(head)
        l1 = head
        l2 = mid.next
        mid.next = None
        l2 = self.reverseList(l2)
        self.mergeList(l1, l2)
    
    def midNode(self, head:ListNode) -> ListNode:
        slow = fast = head
        while fast.next and fast.next.next:
            slow = slow.next
            fast = fast.next.next
        return slow

    def reverseList(self, head:ListNode) -> ListNode:
        pre = None
        cur = head
        while cur:
            tmp = cur.next
            cur.next = pre
            pre = cur
            cur = tmp
        return pre

    def mergeList(self, l1:ListNode, l2:ListNode):
        while l1 and l2:
            l1tmp, l2tmp = l1.next, l2.next
            l1.next = l2
            l2.next = l1tmp
            l1 = l1tmp
            l2 = l2tmp
```



#### ✅[回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

```Python
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:  # 使用list,使用切片判断是否为回文
        vals = []
        cur = head

        while cur:
            vals.append(cur.val)
            cur = cur.next
        return vals[::] == vals[::-1]
```



#### ✅[复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)

```Python
class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        if not head:
            return

        # 第一遍遍历，把每个新生成的结点放在对应的旧结点后面
        p = head
        while p:
            new_node = Node(p.val)
            new_node.next = p.next
            p.next = new_node

            p = new_node.next       # 下一个旧结点
        
        # 第二遍修改每个新结点的 next 和 random 
        p = head
        while p:
            next_origin = p.next.next        # 下一个旧结点备份一下
            p.next.next = next_origin.next if next_origin else None   # 修改新结点的 next
            p.next.random = p.random.next if p.random else None    # 修改新结点的 random

            p = next_origin         # 下一个旧结点
        
        return head.next
```



#### ✅[LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)


```python
class DLinkedNode:
    def __init__(self, key=0, value=0):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None

class LRUCache:  # 双向链表 + 字典(判断缓存有没有)
    def __init__(self, capacity: int):
        self.cache = dict() # {key: DLinkedNode}
        self.capacity = capacity
        self.size = 0
        
        # 使用伪头部和伪尾部节点    
        self.head = DLinkedNode()
        self.tail = DLinkedNode()
        self.head.next = self.tail
        self.tail.prev = self.head        

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        # 如果 key 存在，先通过哈希表定位，再移到头部
        node = self.cache[key]
        self.moveToHead(node)
        return node.value

    def put(self, key: int, value: int) -> None:
        if key not in self.cache:
            # 如果 key 不存在，创建一个新的节点
            node = DLinkedNode(key, value)
            # 添加进哈希表
            self.cache[key] = node
            # 添加至双向链表的头部
            self.addToHead(node)
            self.size += 1
            if self.size > self.capacity: # 只有插入时候才有可能超出容量
                # 如果超出容量，删除双向链表的尾部节点
                removed = self.removeTail()
                # 删除哈希表中对应的项
                self.cache.pop(removed.key)
                self.size -= 1
        else:
            # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            node = self.cache[key]
            node.value = value
            self.moveToHead(node)
    
    def addToHead(self, node):
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node
    
    def removeNode(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev

    def moveToHead(self, node):
        self.removeNode(node)
        self.addToHead(node)

    def removeTail(self):
        node = self.tail.prev
        self.removeNode(node)
        return node
```



