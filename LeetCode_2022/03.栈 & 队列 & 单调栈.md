

#### [字符串解码](https://leetcode-cn.com/problems/decode-string/)

遇到`[`存储前面的res和multi，重新统计当前`[]`里面的res和multi，遇到`]`将当前res和`[`外的multi相乘加到preres后面；

```Python
    def decodeString(self, s: str) -> str:
        stack, res, multi = [], '', 0

        for c in s:
            if c == '[':
                stack.append([multi, res])
                res, multi = '', 0
            elif c == ']':
                premulti, preres = stack.pop()
                res = preres + premulti * res
            elif c.isdigit():
                multi = multi * 10 + int(c) # 12 = 1 *10 + 2 ,一次只能读一位，所以第一次读1，第二次读2，但是数字为12 
            else:
                res += c
        
        return res
```







#### ✅[每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

```python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]: # 单调递减栈

        res = [0 for _ in range(len(temperatures))]
        stack = []

        for i in range(len(temperatures)):
            while stack and temperatures[i] > temperatures[stack[-1]]:
                res[stack.pop()] = i - stack[-1]
            stack.append(i)
        
        return res
```



#### ✅[下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)

```python
class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        stack, dic = [], {}

        for num in nums2:
            while stack and stack[-1] < num:
                dic[stack.pop()] = num
            stack.append(num)
        
        return [dic.get(x, -1) for x in nums1]
```



#### ✅[下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/)

```python
class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:

        new_nums = nums + nums

        res = [-1 for _ in range(len(new_nums))]
        stack = []

        for i in range(len(new_nums)):
            while stack and new_nums[i] > new_nums[stack[-1]]:
                res[stack[-1]] = new_nums[i]
                stack.pop()
            
            stack.append(i)
        
        return res[:len(nums)]
```



#### ✅[接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        # 找每个柱子左右两边第一个大于该柱子高度的柱子
        water = 0
        stack = []

        for i in range(len(height)):
            while stack and height[i] > height[stack[-1]]:  # 维护单调递减栈
                bottom = height[stack.pop()]
                if not stack:  break
                left_height = height[stack[-1]]
                cur_height = min(left_height, height[i]) - bottom
                cur_weight = i - stack[-1] - 1
                water += (cur_height * cur_weight)
            
            stack.append(i)
        
        return water
```



#### ✅[柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

```Python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        # # 找每个柱子左右两边第一个小于该柱子的柱子

        heights = [0] + heights + [0]  # # 左边加0是为了防止栈空，避免增加判断条件;右面加0是为了防止最后栈内残留递增序列，无法完全弹出
        max_rectangle, stack = 0, []

        for i in range(len(heights)):
            while stack and heights[i] < heights[stack[-1]]:
                cur_height = heights[stack.pop()]
                if not stack:  break
                cur_rectangle = (i - stack[-1] - 1) * cur_height
                max_rectangle = max(max_rectangle, cur_rectangle)
            
            stack.append(i)
        
        return max_rectangle
```



#### ✅[去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters/)

```python
class Solution:
    def removeDuplicateLetters(self, s: str) -> str:

        stack = []
        seen = set()
        remain_counter = Counter(s)

        for c in s:
            if c not in seen: # 要求字典序最小，如果前面已经出现过，这次直接跳过（要求一个字符只出现一次）
                while stack and stack[-1] > c and remain_counter[stack[-1]] > 0: # 单调递增栈
                    seen.remove(stack.pop())
                seen.add(c)
                stack.append(c)
            remain_counter[c] -= 1
        
        return ''.join(stack)
```

https://leetcode-cn.com/problems/remove-duplicate-letters/solution/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-4/



#### ✅[移掉 K 位数字](https://leetcode-cn.com/problems/remove-k-digits/)

```python
class Solution:
    def removeKdigits(self, num: str, k: int) -> str:

        stack = [] 
        remain = len(num) - k # 移除k位，保留remain位

        for p in num:
            while k and stack and stack[-1] > p: # 单调递增栈
                stack.pop()
                k -= 1

            stack.append(p)
        
        return   ''.join(stack[:remain]).lstrip('0') or '0'
```



#### ✅[拼接最大数](https://leetcode-cn.com/problems/create-maximum-number/)

```python
class Solution:
    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:

        def pickmax(nums, k):

            stack =[]
            drop = len(nums) - k

            for num in nums:
                while drop and stack and stack[-1] < num:
                    stack.pop()
                    drop -= 1               
                stack.append(num)
            
            return stack[:k]

        
        def merge(numsa, numsb):

            res = []

            while numsa or numsb:
                cur = numsa if numsa > numsb else numsb
                res.append(cur[0])
                cur.pop(0)
                
            return res
        
        return max(merge(pickmax(nums1, i), pickmax(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and (k - i) <= len(nums2)) 
```



