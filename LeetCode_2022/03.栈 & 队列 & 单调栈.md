



#### [逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

- **后缀表达式，其实逆波兰表达式相当于是二叉树中的后序遍历**

```Python
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        def comp(com1, com2, op):
            if op == '+':
                return com1 + com2
            elif op == '-':
                return com1 - com2
            elif op == '*':
                return com1 * com2
            elif op == '/':  # python3 的地板除 "//" 是整数除法， "-3 // 2 = -2" ；
                return int(com1 / float(com2))


        stack = []
        for token in tokens:
            if token in '+-*/':
                com2 = stack.pop()
                com1 = stack.pop()
                stack.append(comp(com1, com2, token))
            else:
                stack.append(int(token))
        
        return stack[0]
```



#### [基本计算器 II](https://leetcode-cn.com/problems/basic-calculator-ii/)

```python
class Solution:
    def calculate(self, s: str) -> int:

        stack = []
        pre_sign, cur_number = '+', 0

        for i, char in enumerate(s):
            if char.isdigit():
                cur_number  = cur_number * 10 + int(char)
            if (i == len(s) - 1) or char in '+-*/':  # 遇到符号就对前面数字和presign更新：数字根据presign存入stack中，然后更新presign=char
                if pre_sign == '+':
                    stack.append(cur_number)
                elif pre_sign == '-':
                    stack.append(-cur_number)
                elif pre_sign == '*':
                    stack.append(stack.pop() * cur_number)
                elif pre_sign == '/':
                    stack.append(int(float(stack.pop()) / cur_number))
                
                cur_number = 0
                pre_sign = char

        return sum(stack)
```



#### [字符串解码](https://leetcode-cn.com/problems/decode-string/)

遇到`[`存储前面的res和multi，重新统计当前`[]`里面的res和multi，遇到`]`将当前res和`[`外的multi相乘加到preres后面；

```Python
    def decodeString(self, s: str) -> str:
        stack, res, multi = [], '', 0

        for c in s:
            if c == '[':
                stack.append([multi, res])
                res, multi = '', 0
            elif c == ']':
                premulti, preres = stack.pop()
                res = preres + premulti * res
            elif c.isdigit():
                multi = multi * 10 + int(c) # 12 = 1 *10 + 2 ,一次只能读一位，所以第一次读1，第二次读2，但是数字为12 
            else:
                res += c
        
        return res
```



## 单调栈

那有同学就问了，我怎么能想到用单调栈呢？ 什么时候用单调栈呢？

**通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了，时间复杂度为O(n)；**

- 单调递增栈：从 栈底 到 栈顶 递增，栈顶大；
- 单调递减栈：从 栈底 到 栈顶 递减，栈顶小；







#### ✅[每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

```python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]: # 单调递减栈

        res = [0 for _ in range(len(temperatures))]
        stack = []

        for i in range(len(temperatures)):
            while stack and temperatures[i] > temperatures[stack[-1]]:
                res[stack.pop()] = i - stack[-1]
            stack.append(i)
        
        return res
```



#### ✅[下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)

```python
class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        stack, dic = [], {}

        for num in nums2:
            while stack and stack[-1] < num:
                dic[stack.pop()] = num
            stack.append(num)
        
        return [dic.get(x, -1) for x in nums1]
```



#### ✅[下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/)

```python
class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:

        new_nums = nums + nums

        res = [-1 for _ in range(len(new_nums))]
        stack = []

        for i in range(len(new_nums)):
            while stack and new_nums[i] > new_nums[stack[-1]]:
                res[stack[-1]] = new_nums[i]
                stack.pop()
            
            stack.append(i)
        
        return res[:len(nums)]
```



#### ✅[接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        # 找每个柱子左右两边第一个大于该柱子高度的柱子
        water = 0
        stack = []

        for i in range(len(height)):
            while stack and height[i] > height[stack[-1]]:  # 维护单调递减栈
                bottom = height[stack.pop()]
                if not stack:  break
                left_height = height[stack[-1]]
                cur_height = min(left_height, height[i]) - bottom
                cur_weight = i - stack[-1] - 1
                water += (cur_height * cur_weight)
            
            stack.append(i)
        
        return water
```



#### ✅[柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

```Python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        # # 找每个柱子左右两边第一个小于该柱子的柱子

        heights = [0] + heights + [0]  # # 左边加0是为了防止栈空，避免增加判断条件;右面加0是为了防止最后栈内残留递增序列，无法完全弹出
        max_rectangle, stack = 0, []

        for i in range(len(heights)):
            while stack and heights[i] < heights[stack[-1]]:
                cur_height = heights[stack.pop()]
                if not stack:  break
                cur_rectangle = (i - stack[-1] - 1) * cur_height
                max_rectangle = max(max_rectangle, cur_rectangle)
            
            stack.append(i)
        
        return max_rectangle
```



#### ✅[去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters/)

```python
class Solution:
    def removeDuplicateLetters(self, s: str) -> str:

        stack = []
        seen = set()
        remain_counter = Counter(s)

        for c in s:
            if c not in seen: # 要求字典序最小，如果前面已经出现过，这次直接跳过（要求一个字符只出现一次）
                while stack and stack[-1] > c and remain_counter[stack[-1]] > 0: # 单调递增栈
                    seen.remove(stack.pop())
                seen.add(c)
                stack.append(c)
            remain_counter[c] -= 1
        
        return ''.join(stack)
```

https://leetcode-cn.com/problems/remove-duplicate-letters/solution/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-4/



#### ✅[移掉 K 位数字](https://leetcode-cn.com/problems/remove-k-digits/)

```python
class Solution:
    def removeKdigits(self, num: str, k: int) -> str:

        stack = [] 
        remain = len(num) - k # 移除k位，保留remain位

        for p in num:
            while k and stack and stack[-1] > p: # 单调递增栈
                stack.pop()
                k -= 1

            stack.append(p)
        
        return   ''.join(stack[:remain]).lstrip('0') or '0'
```



#### ✅[拼接最大数](https://leetcode-cn.com/problems/create-maximum-number/)

```python
class Solution:
    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:

        def pickmax(nums, k):

            stack =[]
            drop = len(nums) - k

            for num in nums:
                while drop and stack and stack[-1] < num:
                    stack.pop()
                    drop -= 1               
                stack.append(num)
            
            return stack[:k]

        
        def merge(numsa, numsb):

            res = []

            while numsa or numsb:
                cur = numsa if numsa > numsb else numsb
                res.append(cur[0])
                cur.pop(0)
                
            return res
        
        return max(merge(pickmax(nums1, i), pickmax(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and (k - i) <= len(nums2)) 
```



