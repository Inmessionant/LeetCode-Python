

#### ✅[柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

```Python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        # # 找每个柱子左右两边第一个小于该柱子的柱子

        heights = [0] + heights + [0]  # # 左边加0是为了防止栈空，避免增加判断条件;右面加0是为了防止最后栈内残留递增序列，无法完全弹出
        max_rectangle, stack = 0, []

        for i in range(len(heights)):
            while stack and heights[i] < heights[stack[-1]]:
                cur_height = heights[stack.pop()]
                if not stack:  break
                cur_rectangle = (i - stack[-1] - 1) * cur_height
                max_rectangle = max(max_rectangle, cur_rectangle)
            
            stack.append(i)
        
        return max_rectangle
```



#### ✅[去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters/)

```python
class Solution:
    def removeDuplicateLetters(self, s: str) -> str:

        stack = []
        seen = set()
        remain_counter = Counter(s)

        for c in s:
            if c not in seen: # 要求字典序最小，如果前面已经出现过，这次直接跳过（要求一个字符只出现一次）
                while stack and stack[-1] > c and remain_counter[stack[-1]] > 0: # 单调递增栈
                    seen.remove(stack.pop())
                seen.add(c)
                stack.append(c)
            remain_counter[c] -= 1
        
        return ''.join(stack)
```

https://leetcode-cn.com/problems/remove-duplicate-letters/solution/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-4/



#### ✅[移掉 K 位数字](https://leetcode-cn.com/problems/remove-k-digits/)

```python
class Solution:
    def removeKdigits(self, num: str, k: int) -> str:

        stack = [] 
        remain = len(num) - k # 移除k位，保留remain位

        for p in num:
            while k and stack and stack[-1] > p: # 单调递增栈
                stack.pop()
                k -= 1

            stack.append(p)
        
        return   ''.join(stack[:remain]).lstrip('0') or '0'
```



#### ✅[拼接最大数](https://leetcode-cn.com/problems/create-maximum-number/)

```python
class Solution:
    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:

        def pickmax(nums, k):

            stack =[]
            drop = len(nums) - k

            for num in nums:
                while drop and stack and stack[-1] < num:
                    stack.pop()
                    drop -= 1               
                stack.append(num)
            
            return stack[:k]

        
        def merge(numsa, numsb):

            res = []

            while numsa or numsb:
                cur = numsa if numsa > numsb else numsb
                res.append(cur[0])
                cur.pop(0)
                
            return res
        
        return max(merge(pickmax(nums1, i), pickmax(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and (k - i) <= len(nums2)) 
```



