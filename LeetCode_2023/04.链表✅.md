## 基础



```python
class ListNode:
    def __init__(self, val, next=None):
        self.val = val
        self.next = next
```



- 链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向`null`；

![20200806194529815](./assets/20200806194529815.png)

- **链表类型：** (1) **单链表**；(2) **双链表**：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点，既可以向前查询也可以向后查询；(3) **循环链表**：链表首尾相连，可以用来解决约瑟夫环问题；



- 链表是通过指针域的指针链接在内存中各个节点，所以**链表中的节点在内存中不是连续分布的** ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理；





## 题目



### ✅[移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

```python
class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:

        if not head:  return head

        dummy_node = ListNode(next=head)
        cur = dummy_node

        while cur.next:
            if cur.next.val == val:
                cur.next = cur.next.next
            else:
                cur = cur.next
        
        return dummy_node.next
```



### ✅[设计链表](https://leetcode.cn/problems/design-linked-list/)

```python
class ListNode:
    def __init__(self, val=0, next=None):

        self.val = val
        self.next = next

class MyLinkedList:

    def __init__(self):

        self.head = ListNode() # dummy_node
        self.count = 0

    def get(self, index: int) -> int:

        if index >= self.count: return -1

    	node = self.head.next

    	for _ in range(index):
        	node = node.next

        return node.val
            


    def addAtHead(self, val: int) -> None:

        return self.addAtIndex(0, val)


    def addAtTail(self, val: int) -> None:

        return self.addAtIndex(self.count, val)


    def addAtIndex(self, index: int, val: int) -> None:

        if index > self.count:  return  # 如果 index 比长度更大，该节点将 不会插入 到链表中

        self.count += 1

        add_node = ListNode(val)

        pre, cur = self.head, self.head.next

        for _ in range(index):
            pre, cur = pre.next, cur.next
        
        # cur位置在index
        pre.next, add_node.next = add_node, cur
        

    def deleteAtIndex(self, index: int) -> None:

        if index >= self.count:
            return 
        
        self.count -= 1
        pre, cur = self.head, self.head.next

        for _ in range(index):
            pre, cur = pre.next, cur.next
        
        # cur位置在index
        pre.next = cur.next
```



### ✅[链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

```python
class ListNode:
    def __init__(self, x):
        
        self.val = x
        self.next = None

class Solution:
    def getKthFromEnd(self, head: ListNode, k: int) -> ListNode:
        
        fast, slow = head, head
        
        for _ in range(k):
            if not fast: return
            fast = fast.next
        
        while fast:
            fast, slow = fast.next, slow.next
        
        return slow
```



### ✅[相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
      
        node1, node2 = headA, headB

        while node1 != node2:
            # 为什么不是node1 = node1.next  if node1.next else headB -> 循环语句跳不出去
            node1 = node1.next if node1 else headB 
            node2 = node2.next if node2 else headA
        
        return node1
```



### ✅[环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

```Python
class Solution:
     # Floyd 判圈算法
    def hasCycle(self, head: ListNode) -> bool: 
        
        if not head or not head.next:
            return False
        
        slow = fast = head

        while True:
            if not fast or not fast.next: # fast或者fast.next为None说明到链表最后了没有环
                return False
            slow = slow.next
            fast = fast.next.next

            if slow == fast:
                return True
```



### ✅[环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

- **这类链表题目一般都是使用双指针法解决的，例如寻找距离尾部第 `K` 个节点、寻找环入口、寻找公共尾部入口等；**



- **假设a(非环部分长度) 、b(环部分长度)，slow一次走1步，fast一次走2步；**
- **当有环时：`slow`和`fast`第一次相遇，此时`slow`走了`a + mb`，fast走了`a + nb`，且`n - m = k`一定是整数（ 解析： 双指针都走过 `a`步，然后在环内绕圈直到重合，重合时 `fast` 比 `slow` 多走 环的长度整数倍 `k`）。且有`fast =2 slow`，因此`slow = kb`；**
- **当`slow`走过路程为`a + kb`时，它一定在入环点，而此时`slow `已经走过了`kb`的距离（`slow = kb`），则`slow`再走`a`距离一定在入环点;**
- **让指针`fast`指向起始点，`fast`与`slow`同时走`a`距离，`slow`和`fast`会第二次相遇，且相遇点一定是入环点；**

```Python
class Solution:
    # https://leetcode.cn/problems/linked-list-cycle-ii/solutions/12616/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/
    def detectCycle(self, head: ListNode) -> ListNode:
        if not head or not head.next: return 

        slow = fast = head

        while True:
            if not fast or not fast.next: return 
            slow, fast = slow.next, fast.next.next
            if slow == fast: break

        fast = head

        while slow != fast:
            slow, fast = slow.next, fast.next
            
        return fast
```



### ✅[删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

```Python
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
      
        if not head or not head.next: 
            return head # 如果链表为空或者只有一个元素，直接返回head
          
        cur = head  # cur指向当前处理的不同元素
        while cur and cur.next: # 当前元素和下一个元素存在才能比较有没有重复，cur到链表最后一个元素时不进入循环
            if cur.val == cur.next.val:
              cur.next = cur.next.next
            else: 
              cur = cur.next

        return head
```



