## 基础



```python
class ListNode:
    def __init__(self, val, next=None):
        self.val = val
        self.next = next
```



- 链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向`null`；

![20200806194529815](./assets/20200806194529815.png)

- **链表类型：** (1) **单链表**；(2) **双链表**：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点，既可以向前查询也可以向后查询；(3) **循环链表**：链表首尾相连，可以用来解决约瑟夫环问题；



- 链表是通过指针域的指针链接在内存中各个节点，所以**链表中的节点在内存中不是连续分布的** ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理；





## 题目



### ✅[移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

```python
class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:

        if not head:  return head

        dummy_node = ListNode(next=head)
        cur = dummy_node

        while cur.next:
            if cur.next.val == val:
                cur.next = cur.next.next
            else:
                cur = cur.next
        
        return dummy_node.next
```



### ✅[设计链表](https://leetcode.cn/problems/design-linked-list/)

```python
class ListNode:
    def __init__(self, val=0, next=None):

        self.val = val
        self.next = next

class MyLinkedList:

    def __init__(self):

        self.head = ListNode() # dummy_node
        self.count = 0

    def get(self, index: int) -> int:

        if index >= self.count: return -1

    	node = self.head.next

    	for _ in range(index):
        	node = node.next

        return node.val
            


    def addAtHead(self, val: int) -> None:

        return self.addAtIndex(0, val)


    def addAtTail(self, val: int) -> None:

        return self.addAtIndex(self.count, val)


    def addAtIndex(self, index: int, val: int) -> None:

        if index > self.count:  return  # 如果 index 比长度更大，该节点将 不会插入 到链表中

        self.count += 1

        add_node = ListNode(val)

        pre, cur = self.head, self.head.next

        for _ in range(index):
            pre, cur = pre.next, cur.next
        
        # cur位置在index
        pre.next, add_node.next = add_node, cur
        

    def deleteAtIndex(self, index: int) -> None:

        if index >= self.count:
            return 
        
        self.count -= 1
        pre, cur = self.head, self.head.next

        for _ in range(index):
            pre, cur = pre.next, cur.next
        
        # cur位置在index
        pre.next = cur.next
```



### ✅[链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

```python
class ListNode:
    def __init__(self, x):
        
        self.val = x
        self.next = None

class Solution:
    def getKthFromEnd(self, head: ListNode, k: int) -> ListNode:
        
        fast, slow = head, head
        
        for _ in range(k):
            if not fast: return
            fast = fast.next
        
        while fast:
            fast, slow = fast.next, slow.next
        
        return slow
```



### ✅[相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
      
        node1, node2 = headA, headB

        while node1 != node2:
            # 为什么不是node1 = node1.next  if node1.next else headB -> 循环语句跳不出去
            node1 = node1.next if node1 else headB 
            node2 = node2.next if node2 else headA
        
        return node1
```



### ✅[环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

```Python
class Solution:
     # Floyd 判圈算法
    def hasCycle(self, head: ListNode) -> bool: 
        
        if not head or not head.next:
            return False
        
        slow = fast = head

        while True:
            if not fast or not fast.next: # fast或者fast.next为None说明到链表最后了没有环
                return False
            slow = slow.next
            fast = fast.next.next

            if slow == fast:
                return True
```



#### ✅[环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

- **快慢指针，快慢相遇之后，快指针回到头，快慢指针步调一致一起移动，再次相遇点即为入环点；**

- **假设a(非环部分长度) 、b(环部分长度)；**

- **slow第一次走到入环点走了`a`，fast走了`a+nb`，而已知`fast=2slow`，则：`a=nb`,`fast=2nb`；**

```Python
class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        if not head or not head.next: return 

        slow = fast = head

        while True:
            if not fast or not fast.next: return 
            slow, fast = slow.next, fast.next.next
            if slow == fast: break

        fast = head

        while slow != fast:
            slow, fast = slow.next, fast.next
            
        return fast
```

