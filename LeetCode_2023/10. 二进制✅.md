------



## 常见二进制操作



### 基本运算符

`& `: **按位与**, 只有` 1&1` 为` 1`，其它情况为` 0`；

` | `: **按位或** , 只有` 0|0` 为`0 `，其他情况为`1`；

 `~ `: 逐位取反；

 `^ `: 异或, 相同为 `0`，相异为 `1`；

` << `: 左移操作，2的幂有关；

` >>` : 右移操作，2的幂有关；



### **异或操作**

- 任何数和 0 做异或运算，结果仍然是原来的数: **`0 ^ n => n`**；
- 任何数和其自身做异或运算，结果是 0: **`n ^ n => 0`**；
- 异或运算满足交换律和结合律: **`a ^ b ^ c <=> a ^ c ^ b`**；
- 异或运算符用于**检测某个值出现次数为奇数**：**奇数次出现异或后都是它本身，偶数次出现异或后都是0**；**`n ^ n = 0, 0 ^ n = n`**



### **Brian Kernighan 算法**

- **用于清除二进制串中最右边的1；**
- `Brian Kernighan `算法的关键在于我们每次对数字` x `和` x−1`进行 **按位与** 运算后，`x` 最右边的 1 会被抹去变成 0；

<img src="https://assets.leetcode-cn.com/solution-static/201/9.png" style="zoom:40%;" />

- 基于上述技巧，我们可以用它来**计算两个二进制字符串的公共前缀；**

    ```python
    res1, res2 = 12, 15
    print(res1, "-> bin()= ", bin(res1))  # 0b1100
    print(res2, "-> bin()= ", bin(res2))  # 0b1111
    
    res = res1 & res2
    print(bin(res))  # 0b1100
    ```





#### ✅[Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)

```python
class Solution:
  # 快速幂：https://leetcode.cn/problems/powx-n/solution/50-powx-n-kuai-su-mi-qing-xi-tu-jie-by-jyd/
    def myPow(self, x: float, n: int) -> float:

        if x == 0: return 0
        
        if n < 0:
            x, n = 1 / x, -n
        
        res = 1
				# 将n分解为二进制，x ** n -> x ** (bin(n))
        while n: # 循环次数为bin(n)的位数
            # 判断bin(n)第k位是否为1，bin(n)第k位对应的x ** (2 ** (k-1))值在k-1位时已经计算，如果bin(n)第k位是为1，则乘到当前res中
            if n & 1: 
                res *= x 
            x *= x # x存储bin(n)第k+1位对应x ** (2 ** (k))值
            n >>= 1 # bin(n)右移一位，可理解为删除bin(n)第k位（当前bin(n)最后一位）
        
        return res
```



#### ✅[只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

```Python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
       # 奇数次出现异或后都是它本身（n^n=0, 0^n=n），偶数次出现异或后都是0
        return reduce(lambda x, y: x ^ y, nums)
      # reduce()将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果
      # reduce(function, iterable[, initializer])
      # function -- 函数，有两个参数
      # iterable -- 可迭代对象
      # initializer -- 可选，初始参数
```

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        setNums = set(nums)
        return 2 * sum(setNums) - sum(nums)
```



####  ✅[只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/)

- 将输入数组存储到 HashSet，然后使用 HashSet 中数字和的三倍与数组之和比较。


```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        return (3*sum(set(nums))-sum(nums))//2
```

- 位运算

```Python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        seen_once = seen_twice = 0
        
        for num in nums:
            seen_once = ~seen_twice & (seen_once ^ num)
            seen_twice = ~seen_once & (seen_twice ^ num)

        return seen_once
```



#### ✅[只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/)

- 1.nums转化为HashSet，然后求和乘以2，减去nums所有元素求和就是只出现一次的两个元素和，相当于给定一个目标值，在列表中找到他们对因位置，输出对应位置的值

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        twoSum = sum(set(nums)) * 2 - sum(nums)

        for i in range(len(nums)):
            tar = twoSum - nums[i]
            if tar in nums:
                return [nums[i], tar]
```

- 2.位运算

```Python
class Solution:
    def singleNumber(self, nums: int) -> List[int]:
        # difference between two numbers (x and y) which were seen only once
        bitmask = 0
        for num in nums:
            bitmask ^= num
        
        # rightmost 1-bit diff between x and y
        diff = bitmask & (-bitmask)
        
        x = 0
        for num in nums:
            # bitmask which will contain only x
            if num & diff:
                x ^= num
        
        return [x, bitmask^x]
```

- 利用Counter统计每个元素出现的次数，返回只出现一次的键。

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        return [key for key, val in Counter(nums).items() if val == 1]
```



#### ✅[位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/)

```Python
class Solution:
   # Brian Kernighan 算法: n & (n-1)每次消除n最右边的1
    def hammingWeight(self, n: int) -> int:
        num_ones = 0
        while n > 0:
            n &= n - 1 # 每次消除最右边的1
        		num_ones += 1

        return num_ones
```

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        return str(bin(n)[2:]).count("1") # bin(10) -> 0b1010
```



#### ✅[比特位计数](https://leetcode-cn.com/problems/counting-bits/)

```Python
# 利用上一题的解法容易想到 O(nk) 的解法，k 为位数，即当前数的1个数等于比它少一个1的数的结果加 1；
class Solution:
    def countBits(self, num: int) -> List[int]:
        
        num_ones = [0] * (num + 1)
        
        for i in range(1, num + 1):
            num_ones[i] = num_ones[i & (i - 1)] + 1
        
        return num_ones
```

```python
class Solution:
    def countBits(self, num: int) -> List[int]:
        res = []

        for i in range(num + 1):
            res.append(str(bin(i)[2:]).count("1"))
        return res
```



#### ✅[颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/)

思路：简单想法依次颠倒即可。更高级的想法是考虑到处理超长比特串时可能出现重复的pattern，此时如果使用 cache 记录出现过的 pattern 并在重复出现时直接调用结果可以节约时间复杂度，

```Python
import functools

class Solution:
    def reverseBits(self, n):
        ret, power = 0, 24
        while n:
            ret += self.reverseByte(n & 0xff) << power
            n = n >> 8
            power -= 8
        return ret

    # memoization with decorator
    @functools.lru_cache(maxsize=256)
    def reverseByte(self, byte):
        return (byte * 0x0202020202 & 0x010884422010) % 1023
```

```python
def reverseBits(self, n: int) -> int:
		# bin()返回的是字符串，bin(20) -> '0b10100'
    # str.zfill(width)
    # width -- 指定字符串的长度,原字符串右对齐，前面填充0
    # 返回指定长度的字符串
    return int(bin(n)[2:].zfill(32)[::-1], 2) # int如果是带参数base的话，要以字符串的形式进行输入
```



#### ✅[数字范围按位与](https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/)

思路：本质上是求[m, n]所有数字的公共前缀

```Python
class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
      # Brian Kernighan 算法可以用来计算两个二进制字符串的公共前缀
        while m < n:
            # 抹去最右边的 1
            n = n & (n - 1)
        return n
```

