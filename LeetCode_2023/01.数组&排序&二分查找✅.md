



## 数组理论基础



- **数组是存放在连续内存空间上的相同类型数据的集合**
- **数组可以方便的通过下标索引的方式获取到下标下对应的数据**

![算法通关数组](./assets/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%84.png)

- **数组内存空间的地址是连续的(我们在删除或者增添元素的时候，就难免要移动其他元素的地址)**

![算法通关数组1](./assets/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%841.png)



## [二分查找](https://leetcode-cn.com/problems/binary-search/)



**二分查找，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)；**



### [left, right]

- **定义 target 是在一个在左闭右闭的区间，也就是`[left, right] `:**
  - `while (left <= right) `要使用` <= `，因为`left == right`有意义，所以使用 `<=`；
  - `if (nums[mid] > target)` right 要赋值为 `mid - 1`：因为当前这个`nums[mid]`一定不是target，那么接下来要查找的左区间结束下标位置就是` mid - 1`；
- **适用范围：**
  - 没有重复元素；
  - 不需要找第一个、最后一个位置；
  - 如果搜索失败，`left` 是第一个大于 target 的索引，`right` 是最后一个小于 `target` 的索引;

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        
        l, r = 0, len(nums) - 1
        
        while l <= r:
            mid = l + (r - l) // 2  # 这样写的目的一个是为了防止 left + right出现溢出，一个是用右移操作替代除法提升性能;
            if nums[mid] == target:
                return mid
            elif nums[mid] > target:  # target 在左区间，所以[left, mid - 1]
                r = mid - 1
            else:  # target 在右区间，所以[mid + 1, right]
                l = mid + 1
        
        return -1
```

















