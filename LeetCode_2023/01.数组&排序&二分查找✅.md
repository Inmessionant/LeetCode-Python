



## 数组理论基础



- **数组是存放在连续内存空间上的相同类型数据的集合**
- **数组可以方便的通过下标索引的方式获取到下标下对应的数据**

![算法通关数组](./assets/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%84.png)

- **数组内存空间的地址是连续的(我们在删除或者增添元素的时候，就难免要移动其他元素的地址)**

![算法通关数组1](./assets/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%841.png)



## [二分查找](https://leetcode-cn.com/problems/binary-search/)



**二分查找，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)；**



### 模板1 -> [left, right]

- **定义 target 是在一个在左闭右闭的区间，也就是`[left, right] `:**
  - `while (left <= right) `要使用` <= `，因为`left == right`有意义，所以使用 `<=`；
  - `if (nums[mid] > target)` right 要赋值为 `mid - 1`：因为当前这个`nums[mid]`一定不是target，那么接下来要查找的左区间结束下标位置就是` mid - 1`；
- **适用范围：**
  - 没有重复元素；
  - 不需要找第一个、最后一个位置；
  - 如果搜索失败，`left` 是第一个大于 target 的索引，`right` 是最后一个小于 `target` 的索引;

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        
        l, r = 0, len(nums) - 1
        
        while l <= r:
            mid = l + (r - l) // 2  # 这样写的目的一个是为了防止 left + right出现溢出，一个是用右移操作替代除法提升性能;
            if nums[mid] == target:
                return mid
            elif nums[mid] > target:  # target 在左区间，所以[left, mid - 1]
                r = mid - 1
            else:  # target 在右区间，所以[mid + 1, right]
                l = mid + 1
        
        return -1
```



### 模板2 -> [left, right)

- https://leetcode.cn/problems/binary-search/solution/leetcode-offer-er-fen-cha-zhao-san-da-mo-0mn7/
- **定义 target 是在一个在左闭右开的区间里，也就是`[left, right)`**：
  - `while (left < right)`，这里使用 `< `，因为`left == right`在区间`[left, right)`是没有意义的；
  - `[left, right] `退出循环的时候有 `left == right` 成立，因此无需考虑返回 `left`还是 `right`；区间`[left, right)`只剩下成 1 个元素，这个元素被漏掉了，此时 `left==right`，它有可能就是我们要找的元素；

- **适用范围：**
  - 数组有序，但包含重复元素；
  - 数组部分有序，且不包含重复元素；
  - 数组部分有序，且包含重复元素；

- **找左边界（从左往右）**
  - 求非降序范围`[l, r)`内第一个不小于`target`的值的位置；
  - 划分` [left, mid]` 与` (mid, right] `，**mid 被分到左边，**对应 `mid = left + (right - left) // 2`;  ->  **mid对于长度为偶数的区间总是偏左的**

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
      
        l, r = 0, len(nums) - 1
        
        while l < r:
            mid = l + (r - l) // 2
            if nums[mid] < target:  # 收缩左边界
                l = mid + 1
            else:  # nums[mid] >= target，收缩右边界，因为我们需要在找到目标值后，继续向左寻找左边界
                r = mid  # mid 被分到左边

        if nums[l] == target:  # 打个补丁,退出循环时:l == r
            return l
        
        return -1
```

- **找右边界（从右往左）**
  - 从右往左找非升序范围内第一个不小于`target`的值的位置；
  - 划分` [left, mid) `与 `[mid, right] `，**mid 被分到右边**，对应  `mid = left + (right - left + 1) // 2;` -> **无论对于奇数还是偶数，这个中间的位置都是偏右的**；

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        
        l, r = 0, len(nums) - 1

        while l < r:
            mid = l + (r - l + 1) // 2
            if target < nums[mid]:  # 收缩右边界
                r = mid - 1
            else:  # 收缩左边界
                l = mid  # mid 被分到右边
        
        if nums[r] == target:
            return r
        else:
            return -1     
```



### ✅[搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

```python
# nums 为无重复元素的升序排列数组，考虑用模板1
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        
        l, r = 0, len(nums) - 1
        
        while l <= r:
            mid = l + (r - l) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] > target:
                r = mid - 1
            else:
                l = mid + 1
        
        return l  # 若不存在，l为第一个大于目标值的索引（插入位置），r为最后一个小于目标值的索引
```



### ✅[在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

```

```



### [寻找峰值](https://leetcode.cn/problems/find-peak-element/)

```

```



### [搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix/)

```

```



### [搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

```

```



### [寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

```

```



### [寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)

```

```



### [搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

```

```



### [搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)

```

```





## 数组排序



#### 快速排序

```

```



#### 归并排序

```

```



#### 堆排序

```

```



## 数组矩阵模拟



#### [螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

```

```



#### [螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)

```

```



#### [路径交叉](https://leetcode-cn.com/problems/self-crossing/)

```

```

