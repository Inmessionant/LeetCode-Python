## 基础



![栈与队列理论2](./assets/20210104235434905.png)

- **队列是先进先出，栈是先进后出；**
- 栈**提供push 和 pop 等接口**，所有元素必须符合**先进后出规则**，所以栈不提供走访功能，也不提供迭代器：不像是set 或者map 提供迭代器来遍历所有元素；
- 栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的，即：**我们可以控制使用哪种容器来实现栈的功能**，所以STL中栈往往不被归类为容器，而被归类为container adapter（**容器适配器**）；
- **我们常用的SGI STL使用deque实现栈**；





## 栈 & 队列



### ✅[最小栈](https://leetcode-cn.com/problems/min-stack/)

- 1.当一个元素要**入栈**时，我们取当**前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中** ;
- 2.当一个元素要**出栈**时，我们把**辅助栈的栈顶元素也一并弹出**；
- 3.在**任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中**；

```Python
class MinStack:
    def __init__(self):
        self.stack = []
        self.mini_stack = [float("inf")]  # 初始化inf，永远比stack存储多

    def push(self, x: int) -> None:
        self.stack.append(x)
        self.min_stack.append(min(x, self.min_stack[-1]))

    def pop(self) -> None:
        self.stack.pop()
        self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]
```



### ✅[最大栈](https://leetcode-cn.com/problems/max-stack/)

```python
class MaxStack:

    def __init__(self):

        self.stack = []
        self.max_stack = [float("-inf")]

    def push(self, x):

        self.stack.append(x)
        self.max_stack.append(max(self.max_stack[-1], x))

    def pop(self):

        self.max_stack.pop()
        return self.stack.pop()

    def top(self):

        return self.stack[-1]

    def peekMax(self):

        return self.max_stack[-1]

    def popMax(self):

        max_number = self.peekMax()  # 先明确最大值

        buffer_stack = []

        while self.top() != max_number:  # 当前top值不是最大值，要先存起来
            buffer_stack.append(self.pop())  # 同时弹出stack与max_stack

        self.pop()  # 取出最大值

        while buffer_stack:
            self.push(buffer_stack.pop())

        return max_number
```



### ✅[用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

```python
class MyQueue:

    def __init__(self):
        self.stack = []
        self.cache = []

    def push(self, x: int) -> None:
        self.stack.append(x)

    def pop(self) -> int:
        if not self.cache:
            while self.stack:
                self.cache.append(self.stack.pop())
        return self.cache.pop()

    def peek(self) -> int:
        if self.cache:
            return self.cache[-1]
        return self.stack[0]

    def empty(self) -> bool:
        return not self.stack and not self.cache

# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()
```



### ✅[用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

```python
class MyStack:

    def __init__(self):
        self.queue = deque() # 最左端为最近一次添加的元素（栈顶）,用队列模拟，必须是先进先出

    def push(self, x: int) -> None:

        n = len(self.queue)
        self.queue.append(x)
        for _ in range(n):
            self.queue.append(self.queue.popleft())

    def pop(self) -> int:
        return self.queue.popleft()

    def top(self) -> int:
        return self.queue[0]

    def empty(self) -> bool:
        return not self.queue
```



### ✅[验证栈序列](https://leetcode.cn/problems/validate-stack-sequences/)

```python
class Solution:
    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:

        stack = []
        idx = 0  # 用于指示指向poped的当前元素

        for value in pushed:

            stack.append(value)

            while stack and stack[-1] == popped[idx]:
                stack.pop()
                idx += 1

        return True if not stack and idx == len(popped) else False
```



### ✅[有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

```python
class Solution:
    def isValid(self, s: str) -> bool:

        stack = []

        for c in s:
            if c in "([{":
                stack.append(c)
            else:
                if stack:
                    if c == ")" and stack.pop() != "(":
                        return False
                    elif c == "]" and stack.pop() != "[":
                        return False
                    elif c == "}" and stack.pop() != "{":
                        return False

                else:
                    return False

        return True if not stack else False
```



### [逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

```

```



### [基本计算器 II](https://leetcode-cn.com/problems/basic-calculator-ii/)

```

```



### [字符串解码](https://leetcode-cn.com/problems/decode-string/)

```

```



## 单调栈

