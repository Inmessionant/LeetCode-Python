# 时间复杂度



- 就是业内的一个默认规定，这里说的O代表的就是一般情况，而不是严格的上界；
- 在决定使用哪些算法的时候，不是时间复杂越低的越好（因为简化后的时间复杂度忽略了常数项等等），要考虑数据规模，如果数据规模很小甚至可以用O(n^2)的算法比O(n)的更合适（在有常数项的时候）；

![时间复杂度，不同数据规模的差异](1.%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.assets/20200728191447384.png)

- **我们说的时间复杂度都是省略常数项系数的，是因为一般情况下都是默认数据规模足够的大，基于这样的事实，给出的算法时间复杂的的一个排行如下所示**：

  ```
  O(1)常数阶 < O(logn)对数阶 < O(n)线性阶 < O(n^2)平方阶 < O(n^3)立方阶 < O(2^n)指数阶
  ```

- **递归算法的空间复杂度 =  递归的次数 * 每次递归中的操作次数**；



- x的n次方

```c++
//时间复杂度为O(n)
int function1(int x, int n) {
    int result = 1;  // 注意 任何数的0次方等于1
    for (int i = 0; i < n; i++) {
        result = result * x;
    }
    return result;
}

//时间复杂度为O(n)
int function2(int x, int n) {
    if (n == 0) {
        return 1; // return 1 同样是因为0次方是等于1的
    }
    return function2(x, n - 1) * x;
}

//时间复杂度为O(logn)
int function4(int x, int n) {
    if (n == 0) {
        return 1;
    }
    int t = function4(x, n / 2);// 这里相对于function3，是把这个递归操作抽取出来
    if (n % 2 == 1) {
        return t * t * x;
    }
    return t * t;
}
```





# 空间复杂度



- 空间复杂度是**考虑程序运行时占用内存的大小**，而不是可执行文件的大小；
- 空间复杂度是**预先大体评估程序内存使用的大小**，不要以为空间复杂度就已经精准的掌握了程序的内存使用大小，很多因素会影响程序真正内存使用大小，例如编译器的内存对齐，编程语言容器的底层实现等等这些都会影响到程序内存的开销；
- **递归算法的空间复杂度 = 每次递归的空间复杂度 \* 递归深度**；





# 内存对齐



**不要以为只有C/C++才会有内存对齐，只要可以跨平台的编程语言都需要做内存对齐，Java、Python都是一样的**。**为什么会有内存对齐？**

- **平台原因：**不是所有的硬件平台都能访问任意内存地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。为了同一个程序可以在多平台运行，需要内存对齐；
- **硬件原因：**经过内存对齐后，CPU访问内存的速度大大提升；



假设CPU把内存划分为4字节大小的块，要读取一个4字节大小的int型数据，来看一下这两种情况下CPU的工作量：

第一种就是内存对齐的情况，如图：

![内存对齐](1.%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.assets/20200804193307347.png)

一字节的char占用了四个字节，空了三个字节的内存地址，int数据从地址4开始。此时，直接将地址4，5，6，7处的四个字节数据读取到即可。



第二种是没有内存对齐的情况如图：

![非内存对齐](1.%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.assets/20200804193353926.png)

char型的数据和int型的数据挨在一起，该int数据从地址1开始，那么CPU想要读这个数据的话来看看需要几步操作：

1. 因为CPU是四个字节四个字节来寻址，首先CPU读取0，1，2，3处的四个字节数据
2. CPU读取4，5，6，7处的四个字节数据
3. 合并地址1，2，3，4处四个字节的数据才是本次操作需要的int数据。此时一共需要两次寻址，一次合并的操作。



- **大家可能会发现内存对齐浪费内存资源，但事实上相对来说计算机内存资源一般都是充足的，我们更希望的是提高运行速度；**
- **编译器一般都会做内存对齐的优化操作，也就是说当考虑程序真正占用的内存大小的时候，也需要认识到内存对齐的影响；**